<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>ЕГЭ.ctb</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><a name="ЕГЭ_1.html"></a><h1 class='title level-1'>ЕГЭ</h1><br/><p>В данном файле ещё не учтены задания демо-варианта на 2025 год:<ul><li>для задания №24: максимальная длина подстроки, являющейся правильным арифметическим выражением (регулярные выражения);</li><li>для задания №26: сложные многокритериальные сортировки.</li></ul></p></div><div class='page'><a name="ЕГЭ--1._Соотнесение_таблицы_и_графа_2.html"></a><h1 class='title level-2'>1. Соотнесение таблицы и графа</h1><br/><p><h1>Как решать</h1><ol><li>Отмечаем на графе степени вершин.</li><li>Определяем вершины с уникальными степенями. <em><small>Пример: только одна вершина со степенью 4</small></em><small>.</small></li><li>Определяем вершины, уникально связанные с уже найденными. <em><small>Пример: только одна вершина, соседняя с вершинами №3 и №7.</small></em></li><li>Формулируем более сложные критерии, справедливые только для одной вершины. <em><small>Пример: только одна вершина со степенью 3, соседняя с вершиной №2, но не соседняя с вершиной №5.</small></em></li><li>Повторяем пп. 3 и 4, пока не найдём все возможное (или необходимое).</li><li>Если больше ничего не помогает, то выбираем (предполагаем), что вершина на графе имеет какой-то номер; затем проверяем это предположение на отсутствие противоречий.</li></ol></p><p></p><p><h1>Что предлагается найти</h1><ul><li>некоторые вершины (их номера в таблице);</li><li>вес ребра (длину дороги);</li><li>сумму весов некоторых рёбер;</li><li>длину кратчайшего пути (для этого нужно соотнести все вершины и рёбра).</li></ul></p><p></p><p><h1>Типы соотнесения</h1><ul><li>Однозначное соотнесение: есть только один вариант соотнесения вершин в таблице и графе.</li><li>Неоднозначное соотнесение:<ul><li>есть два или больше вариантов соотнести вершины в таблице и графе;</li><li>у графа может быть заметна симметрия, которая и показывает неоднозначность;</li><li>при решении можно выбрать (предположить) один из вариантов соотнесения или рассматривать сразу несколько.</li></ul></li></ul></p><p></p><p><h1>Программное решение</h1></p><p>Компактное решение, основанное на переборе перестановок вершин относительно порядковых номеров.</p><p>Автор - Леонид Шастин.</p><p>В переменную s вносятся номпера соседних вершин для каждой строки матрицы смежности.</p><p>В переменную v вносятся рёбра графа.</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">itertools</span> <span style="color:#a020f0;font-weight:400">import</span> permutations <span style="color:#a020f0;font-weight:400">as</span> pm<br /><br />s = <span style="color:#ff00ff;font-weight:400">&#39;457 46 567 12 136 235 13&#39;</span>.split()<br />v = <span style="color:#ff00ff;font-weight:400">&#39;fe ec ca ab bd df fg dg gc&#39;</span>.split()<br /><br /><span style="color:#008a8c;font-weight:400">print</span>(*<span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#ff00ff;font-weight:400">8</span>))<br /><br /><span style="color:#a52a2a;font-weight:700">for</span> p <span style="color:#a52a2a;font-weight:700">in</span> pm(<span style="color:#ff00ff;font-weight:400">&#39;abcdefg&#39;</span>):<br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">all</span>(<span style="color:#008a8c;font-weight:400">str</span>(p.index(b) + <span style="color:#ff00ff;font-weight:400">1</span>) <span style="color:#a52a2a;font-weight:700">in</span> s[p.index(a)] <span style="color:#a52a2a;font-weight:700">for</span> a, b <span style="color:#a52a2a;font-weight:700">in</span> v):<br />        <span style="color:#008a8c;font-weight:400">print</span>(*p)</pre></div></p></div><div class='page'><a name="ЕГЭ--2._Таблица_истинности_3.html"></a><h1 class='title level-2'>2. Таблица истинности</h1><br/><p><h1>Аналитическое решение</h1><ol><li>Используем свойства конъюнкции и дизъюнкции:<ul><li>конъюнкция истинна, когда все её элементы истинны;</li><li>дизъюнкция ложна, когда все её элементы ложны.</li></ul></li><li>Раскладываем выражение на систему более простых уравнений.</li><li>Определяем столбцы из всех нулей и всех единиц (при наличии): переменная всегда ложна или всегда истинна.</li><li>Определяем значения в таблице и переменные в столбцах, исходя из уравнений, заполняем таблицу.</li><li>Если однозначно определить не получается, то перебираем возможные варианты соотнесения столбцов и переменных.</li><li>Учитываем уникальность строк (по условию и по смыслу).</li><li>Учитываем уникальность столбцов (из однозначности ответа).</li><li>Повторяем пп. 5-8, пока не определим столбцы всех переменных.</li></ol></p><p></p><p><h1>Программное решение</h1></p><p>Пишем программу на вывод строк таблицы истинности с нужным значением функции.</p><p>Типовая программа:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">for</span> w <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#ff00ff;font-weight:400">0</span>, <span style="color:#ff00ff;font-weight:400">1</span>: <br />    <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#ff00ff;font-weight:400">0</span>, <span style="color:#ff00ff;font-weight:400">1</span>: <br />        <span style="color:#a52a2a;font-weight:700">for</span> y <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#ff00ff;font-weight:400">0</span>, <span style="color:#ff00ff;font-weight:400">1</span>: <br />            <span style="color:#a52a2a;font-weight:700">for</span> z <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#ff00ff;font-weight:400">0</span>, <span style="color:#ff00ff;font-weight:400">1</span>: <br />                <span style="color:#a52a2a;font-weight:700">if</span> условие: <br />                    <span style="color:#008a8c;font-weight:400">print</span>(w, x, y, z)</pre></div></p><p>Применяемые логические операции:</p><p><table class="table"><tr><th>Логика</th><th>Python</th></tr><tr><td>инверсия (¬, &quot;не&quot;)</td><td>not</td></tr><tr><td>конъюникция (∧,&quot;и&quot;)</td><td>and</td></tr><tr><td>дизъюнкция (∨, &quot;или&quot;)</td><td>or</td></tr><tr><td>импликация (→)</td><td>&lt;=</td></tr><tr><td>строгая дизъюнкция (⊕, искл. “или”)</td><td>^, !=</td></tr><tr><td>эквиваленция (⇔)</td><td>==</td></tr></table></p><p>Если всё условие должно быть ложным, то ставим его в скобки и используем “not”.</p><p>При записи выражений определяем порядок действий при помощи скобок.</p><p>Выведенных программой строк не должно быть меньше или намного больше, чем указанных в задании. Порядок строк может быть любым.</p><p>Пытаемся определить лишние строки (если есть).</p><p>Сопоставляем строки в задании и строки, выведенные программой:<ul><li>основываемся на уникальных строках и столбцах (<small>пример: только одна строка с тремя единицами</small>);</li><li>меняем порядок переменных в операторе вывода, пока не совпадёт порядок значений во всех строках.</p><p></li></ul></p></div><div class='page'><a name="ЕГЭ--3._Базы_данных_4.html"></a><h1 class='title level-2'>3. Базы данных</h1><br/><p>Применяем фильтры на поля.</p><p>Сначала ставим те фильтры, которые не будут меняться.</p><p>Если не уверены или запутались, то переделываем задание полностью.</p><p>Соблюдаем единицы измерения.</p><p>Контролируем правильность фильтрации по датам.</p></div><div class='page'><a name="ЕГЭ--4._Кодирование_и_декодирование_5.html"></a><h1 class='title level-2'>4. Кодирование и декодирование</h1><br/><p><h1>Виды заданий</h1><ul><li>Префиксное кодирование:<ul><li>требуется найти код символа;</li><li>требуется найти суммарную длину некоторых кодов;</li><li>требуется найти минимальную длину кода сообщения.</li></ul></li><li>Постфиксное кодирование:<ul><li>решаем как префиксное, но дерево кодов выписываем по кодам справа налево.</li></ul></li><li>Помехоустойчивые коды:<ul><li>Побитово выписываем самые редкие значения бит.</li></ul></li></ul></p><p></p><p><h1>Как решать (префиксное кодирование)</h1><ul><li>Если есть известные коды:<ol><li>Строим дерево кодов, внося в него известные коды.</li><li>Вносим неизвестные коды:<ul><li>если не учитываем частоту символов, то делаем дерево сбалансированным: лдя разветвлений всегда выбираем самые короткие ветви;</li></ul></li></ol></li></ul></p><p>      если дано конкретное сообщение, то учитываем частоту символов и рассматриваем не менее двух вариантов:<ol><li>самый частый символ находится на самой короткой ветви;</li><li>два самых частых символа делят самую короткую ветвь.</li><li>Если нет заранее известных кодов, то используем алгоритм Хаффмана:</li><li>выписываем все частоты символов в отдельные группы;</li><li>объединяем две самые малочисленные группы в одну группу, убираем эти группы;</li><li>продолжаем п. 2, пока не останется одна группа;</li><li>“расправляем” полученное дерево;</li><li>вычисляем ответ (можно по сумме чисел в узлах дерева).</li></ol></p></div><div class='page'><a name="ЕГЭ--5._Исполнитель_с_цифрами_6.html"></a><h1 class='title level-2'>5. Исполнитель с цифрами</h1><br/><p><h1>Как решать</h1></p><p>Многие задания удобнее решать не аналитически, а программой - перебором чисел и выполнением алгоритма на каждом из них.</p><p>Типовая программа (для двоичной системы счисления):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#ff00ff;font-weight:400">1000</span>): <br />    s = <span style="color:#008a8c;font-weight:400">bin</span>(n)[<span style="color:#ff00ff;font-weight:400">2</span>:] <br />    ПРЕОБРАЗОВАНИЯ СТРОКИ s <br />    r = <span style="color:#008a8c;font-weight:400">int</span>(n, <span style="color:#ff00ff;font-weight:400">2</span>) <br />    <span style="color:#a52a2a;font-weight:700">if</span> УСЛОВИЕ НА n ИЛИ r: <br />        <span style="color:#008a8c;font-weight:400">print</span>(n, r)</pre></div></p><p>Если система счисления не двоичная, то пишем и используем функцию преобразования в неё.</p><p>Пример для троичной системы счисления:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">def</span> <span style="color:#008a8c;font-weight:400">t</span>(n): <br />    s = <span style="color:#ff00ff;font-weight:400">&#39;&#39;</span> <br />    <span style="color:#a52a2a;font-weight:700">while</span> n &gt; <span style="color:#ff00ff;font-weight:400">0</span>: <br />        s = <span style="color:#008a8c;font-weight:400">str</span>(n % <span style="color:#ff00ff;font-weight:400">3</span>)[<span style="color:#ff00ff;font-weight:400">2</span>:] + s <br />        n //= <span style="color:#ff00ff;font-weight:400">3</span> <br />    <span style="color:#a52a2a;font-weight:700">return</span> s</pre></div></p><p>Для замены символов в определённых местах используем срезы с добавлением символов.</p><p>Например, “замена” двух первых символов нулями:</p><p><div class="codebox"><pre>s = <span style="color:#ff00ff;font-weight:400">&#39;00&#39;</span> + s[<span style="color:#ff00ff;font-weight:400">2</span>:]</pre></div></p><p>Проверяем корректность срезов и индексов предварительно, на строках типа ‘abcdefgh’.</p><p>У небольших значений исходного числа может не быть нужного числа цифр в заданной системе счисления, поэтому перебор нужно начинать не всегда с 1.</p><p>Для определения наименьшего подходящего числа используем break после вывода, для наибольшего - смотрим последнее выведенное.</p><p>Контролируем, какое именно значение нужно получить, - исходное или итоговое.</p><p>Иногда итоговое значение (R) не всегда возрастает при возрастании исходного (N). В этом случае изучаем вывод всех подходящих N и R и выбираем нужное. Либо используем помещение значений в список и ищем ответ с помощью max/min.</p><p>Контролируем правильность битов чётность (относительно каких именно бит).</p></div><div class='page'><a name="ЕГЭ--6._Анализ_результата_работы_исполнителя_7.html"></a><h1 class='title level-2'>6. Анализ результата работы исполнителя</h1><br/><p><h1>Черепаха</h1></p><p><h2>Как решать</h2></p><p>Если есть непрямые углы, то изображение и анализ результата без клеточек, линейки и транспортира обычно затруднено. При возможности используем программу:</p><p></p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">turtle</span> <span style="color:#a020f0;font-weight:400">import</span> * <br />tracer(<span style="color:#ff00ff;font-weight:400">0</span>)<br />screensize(<span style="color:#ff00ff;font-weight:400">1000</span>, <span style="color:#ff00ff;font-weight:400">1000</span>) <br />m = <span style="color:#ff00ff;font-weight:400">20</span> <br />left(<span style="color:#ff00ff;font-weight:400">90</span>)<br /><span style="color:#0000ff;font-weight:400"># Программа Черепахи </span><br /><span style="color:#a52a2a;font-weight:700">for</span> _ <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">4</span>): <br />    forward(<span style="color:#ff00ff;font-weight:400">11</span> * m) <br />    right(<span style="color:#ff00ff;font-weight:400">45</span>) <br />    forward(<span style="color:#ff00ff;font-weight:400">12</span> * m) <br />    right(<span style="color:#ff00ff;font-weight:400">135</span>) <br /><span style="color:#0000ff;font-weight:400"># Постановка точек </span><br />up() <br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">0</span>, <span style="color:#ff00ff;font-weight:400">20</span>): <br />    <span style="color:#a52a2a;font-weight:700">for</span> y <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">0</span>, <span style="color:#ff00ff;font-weight:400">20</span>): <br />        goto(x * m, y * m) <br />        dot(<span style="color:#ff00ff;font-weight:400">5</span>) <br />update() <br />Screen().exitonclick()</pre></div></p><p></p><p>Если есть только прямые углы, то воспроизводим чертёж схематично сами.</p><p></p><p><h2>Что нужно найти</h2></p><p>Значения, которые обычно требуется найти:<ul><li>для прямоугольника:<ul><li>площадь: a*b;</li><li>периметр: (a+b)*2;</li><li>количество целочисленных точек, включая границы: (a+1)*(b+1);</li><li>количество целочисленных точек, исключая границы: (a-1)*(b-1).</li></ul></li></ul></p><p>Область, в которой обычно требуется найти значения:<ul><li>пересечение других областей: N(A и B);</li><li>объединение других областей: N(A или B) = N(A) + N(B) - N(A и B);</li><li>разность других областей: N(A и не B) = N(A) - N(A и B);</li><li>симметрическая разность других областей: N(A xor B) = N(A) + N(B) - 2*N(A и B).</p><p></li></ul></p></div><div class='page'><a name="ЕГЭ--7._Кодирование_графики,_звука_11.html"></a><h1 class='title level-2'>7. Кодирование графики, звука</h1><br/><p><h1>Графика</h1></p><p><h2>Определение информационного объёма изображения</h2></p><p>Информационный объём изображения: I<sub>бит</sub>=Р<sub>в</sub>*Р<sub>г</sub>*b<sub>бит</sub>, где:<ul><li>Р<sub>в </sub>- размер изображения (число пикселей) по вертикали;</li><li>Р<sub>г </sub>- размер изображения (число пикселей) по горизонтали;</li><li>b - число бит на пиксель (глубина цвета, если кодируется только цвет).</li></ul></p><p>Число цветов: Цв = 2<sup>b</sup> (если кодируется только цвет).</p><p><h2>Определение максимального числа цветов</h2></p><p>Виды заданий:<ul><li>нет дополнительных условий;</li><li>присутствуют дополнительные биты (прозрачность, чётность и т. п.); их нужно отнять от b перед определением числа цветов; формулировки:<ul><li>N дополнительных бит на пиксель;</li><li>каждый N-й бит - дополнительный;</li><li>после каждых N бит идёт один дополнительный бит.</li></ul></li><li>есть сжатие:<ul><li>сжатие уменьшило объём на N%;</li><li>сжатый файл составил N% от несжатого;</li><li>исходный файл на N% больше сжатого;</li><li>сжатие уменьшило объём в N раз.</li></ul></li></ul></p><p>Как решаем:<ul><li>составляем неравенство относительно глубины цвета, правильно учитываем возможное сжатие, решаем неравенство;</li><li>округляем ограничение глубины цвета вниз, при необходимости - убираем дополнительные биты;</li><li>для ответа находим число цветов.</li></ul></p><p></p><p><h2>Перекодирование изображения</h2></p><p>При перекодировании цвета изменение информационного объёма пропорционально изменению b и пропорционально квадрату изменения разрешения (если не указано, какое именно из двух разрешений изменяется).</p><p>Если при перекодировании нужно найти итоговый объём, то считаем напрямую. Если нужно найти исходный объём, то считаем наоборот или составляем и решаем уравнение.</p><p></p><p><h1>Звук</h1></p><p><h2>Определение информационного объёма звука</h2></p><p>Информационный объём звука: I<sub>бит</sub>=t<sub>с</sub>*ЧД<sub>Гц</sub>*b<sub>бит</sub>*k, где:<ul><li>t - время звучания;</li><li>ЧД - частота дискретизации (1 кГц = 1000 Гц);</li><li>b - глубина кодирования, разрешение;</li><li>k - число каналов (1 - моно, 2 - стерео, 4 - квадро).</li></ul></p><p>Число уровней дискретизации: Ур = 2<sup>b</sup>.</p><p><h2>Перекодирование звука</h2></p><p>При перекодировании звука изменение информационного объёма пропорционально изменению t, ЧД, b, k.</p><p>Если при перекодировании нужно найти итоговый объём, то считаем напрямую. Если нужно найти исходный объём, то считаем наоборот или составляем и решаем уравнение.</p><p></p><p><h1>Передача информации</h1></p><p>Соотношения:<ul><li>скорость передачи информации: V<sub>бит/с</sub>=I<sub>бит</sub> / t<sub>с</sub>;</li><li>время передачи обратно пропорционально скорости;</li><li>1 кбит/с = 1000 бит/с, 1 Мбит/с = 1000 кбит/с и т. д.</p><p></li></ul></p></div><div class='page'><a name="ЕГЭ--8._Комбинаторика_12.html"></a><h1 class='title level-2'>8. Комбинаторика</h1><br/><p><h1>Что нужно знать</h1><ul><li>Комбинаторные правила:<ul><li>правило сложения: разные варианты составления объекта;</li><li>правило умножения: составной объект из независимых частей; </li><li>правило включения-исключения: разные, но пересекающиеся варианты составления объекта.</li></ul></li><li>Комбинаторные объекты:<ul><li>перестановки: N разных элементов, N мест, порядок важен, P(N)=N!;</li><li>размещения с повторениями: N элементов, K мест, порядок важен, возможны повторения: A&#39;(N, K) = N<sup>K</sup>;</li><li>размещения без повторений: N элементов, K мест, порядок важен: A&#39;(N, K) = N!/(N-K)!;</li><li>сочетания без повторений: N элементов, K мест, порядок не важен: C(N, K) = N!/((N-K)! * K!).</li></ul></li><li>Буквы/слова нужно сортировать в алфавитном порядке.</li><li>Модуль itertools:<ul><li>permutations - перестановки;</li><li>product - размещения с повторениями;</li><li>combinations - сочетания без повторений.</li></ul></li><li>Проверка уникальности элементов: len(a) == len(set(a))</li></ul></p><p></p><p><h1>Виды заданий</h1></p><p><h2>Слова по порядку</h2></p><p><h4>Требуется найти номер слова в списке</h4></p><p>Решение через системы счисления:<ol><li>отмечаем, что буквы по алфавиту соответствуют цифрам некоторой системы счисления;</li><li>превращаем слово в число, записанное в этой системе счисления;</li><li>записываем число в десятичной системе счисления;</li><li>прибавляем 1 к результату, т. к. “нулевое” слово имеет номер 1.</li></ol></p><p>Возможно решение программой. Пример: </p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">itertools</span> <span style="color:#a020f0;font-weight:400">import</span> product <br />a = [<span style="color:#ff00ff;font-weight:400">&#39;&#39;</span>.join(p) <span style="color:#a52a2a;font-weight:700">for</span> p <span style="color:#a52a2a;font-weight:700">in</span> product(<span style="color:#ff00ff;font-weight:400">&#39;АКОСТ&#39;</span>, repeat=<span style="color:#ff00ff;font-weight:400">4</span>)] <br />a.sort() <br /><span style="color:#008a8c;font-weight:400">print</span>(a.index(<span style="color:#ff00ff;font-weight:400">&#39;СОТА&#39;</span>) + <span style="color:#ff00ff;font-weight:400">1</span>)</pre></div></p><p><h4>Требуется найти слово по его номеру в списке</h4></p><p>Решение через системы счисления:<ol><li>вычитаем 1 из номера, т. к. “нулевое” слово имеет номер 1;</li><li>отмечаем, что буквы по алфавиту соответствуют цифрам некоторой системы счисления;</li><li>записываем число в этой системе счисления;</li><li>превращаем число в слово;</li><li>добавляем в начало слова “нулевые” буквы при необходимости.</li></ol></p><p>Возможно решение программой. Пример: </p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">itertools</span> <span style="color:#a020f0;font-weight:400">import</span> product <br />a = [<span style="color:#ff00ff;font-weight:400">&#39;&#39;</span>.join(p) <span style="color:#a52a2a;font-weight:700">for</span> p <span style="color:#a52a2a;font-weight:700">in</span> product(<span style="color:#ff00ff;font-weight:400">&#39;АКОСТ&#39;</span>, repeat=<span style="color:#ff00ff;font-weight:400">4</span>)] <br />a.sort() <br /><span style="color:#008a8c;font-weight:400">print</span>(a[<span style="color:#ff00ff;font-weight:400">446</span> - <span style="color:#ff00ff;font-weight:400">1</span>])</pre></div></p><p></p><p><h2>Количество слов</h2></p><p><h3>Есть повторяющиеся буквы</h3></p><p>Можно использовать комбинаторные формулы и перебор вариантов формирования слов или программу.</p><p>Пример программы:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">itertools</span> <span style="color:#a020f0;font-weight:400">import</span> product <br />a = [] <br /><span style="color:#a52a2a;font-weight:700">for</span> p <span style="color:#a52a2a;font-weight:700">in</span> product(<span style="color:#ff00ff;font-weight:400">&#39;АКОСТ&#39;</span>, repeat=<span style="color:#ff00ff;font-weight:400">4</span>): <br />    w = <span style="color:#ff00ff;font-weight:400">&#39;&#39;</span>.join(p) <br />    <span style="color:#a52a2a;font-weight:700">if</span> w.count(<span style="color:#ff00ff;font-weight:400">&#39;А&#39;</span>) + w.count(<span style="color:#ff00ff;font-weight:400">&#39;О&#39;</span>) == <span style="color:#ff00ff;font-weight:400">2</span>: <br />        a.append(w) <br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#008a8c;font-weight:400">len</span>(a))</pre></div></p><p><h3>Нет повторяющихся букв</h3></p><p>Можно использовать комбинаторные формулы и перебор вариантов формирования слов или программу.</p><p>Пример программы:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">itertools</span> <span style="color:#a020f0;font-weight:400">import</span> permutations <br />a = [] <br /><span style="color:#a52a2a;font-weight:700">for</span> p <span style="color:#a52a2a;font-weight:700">in</span> permutations(<span style="color:#ff00ff;font-weight:400">&#39;АКОСТ&#39;</span>): <br />    w = <span style="color:#ff00ff;font-weight:400">&#39;&#39;</span>.join(p) <br />    <span style="color:#a52a2a;font-weight:700">if</span> w[<span style="color:#ff00ff;font-weight:400">3</span>] != <span style="color:#ff00ff;font-weight:400">&#39;С&#39;</span> <span style="color:#a52a2a;font-weight:700">and</span> <span style="color:#ff00ff;font-weight:400">&#39;ТА&#39;</span> <span style="color:#a52a2a;font-weight:700">not</span> <span style="color:#a52a2a;font-weight:700">in</span> w: <br />        a.append(w) <br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#008a8c;font-weight:400">len</span>(a))</pre></div></p><p>Пример программы (вместо permutations используется product с проверкой уникальности букв слова через множество):</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">itertools</span> <span style="color:#a020f0;font-weight:400">import</span> product <br />a = [] <br /><span style="color:#a52a2a;font-weight:700">for</span> p <span style="color:#a52a2a;font-weight:700">in</span> product(<span style="color:#ff00ff;font-weight:400">&#39;АКОСТ&#39;</span>, repeat=<span style="color:#ff00ff;font-weight:400">5</span>): <br />    w = <span style="color:#ff00ff;font-weight:400">&#39;&#39;</span>.join(p) <br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">len</span>(w) == <span style="color:#008a8c;font-weight:400">len</span>(<span style="color:#008a8c;font-weight:400">set</span>(w)) andw[<span style="color:#ff00ff;font-weight:400">3</span>] != <span style="color:#ff00ff;font-weight:400">&#39;С&#39;</span> <span style="color:#a52a2a;font-weight:700">and</span> <span style="color:#ff00ff;font-weight:400">&#39;ТА&#39;</span> <span style="color:#a52a2a;font-weight:700">not</span> <span style="color:#a52a2a;font-weight:700">in</span> w: <br />        a.append(w) <br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#008a8c;font-weight:400">len</span>(a))</pre></div></p><p></p><p><h2>Количество чисел</h2></p><p>Нулей в начале натурального числа не бывает.</p></div><div class='page'><a name="ЕГЭ--9._Табличный_процессор_13.html"></a><h1 class='title level-2'>9. Табличный процессор</h1><br/><p><h1>Типы заданий</h1></p><p>Если в условии мало вариантов для перебора (например, 3 числа и нужно перебрать все пары из них), то пишем формулу с рассмотрением всех вариантов.</p><p></p><p>Если есть возможность, то меняем значения в первой строке с целью проверить правильность формулы. Не забудем после этого вернуть изначальные значения.</p><p></p><p>Если речь идёт о наибольших, наименьших, остальных, средних и т. п. числах, либо мы понимаем, что лучше бы упорядочить числа, то упорядочиваем: создаём новые столбцы для упорядочивания (сортировки) чисел, используем функцию НАИМЕНЬШИЙ или НАИБОЛЬШИЙ.</p><p> Пример для 3 чисел:</p><p><table class="table"><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr><tr><td>4</td><td>7</td><td>9</td><td>=НАИБОЛЬШИЙ(A1:C1; 3)</td><td>=НАИБОЛЬШИЙ(A1:C1; 2)</td><td>=НАИБОЛЬШИЙ(A1:C1; 1)</td></tr><tr><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td></tr></table> </p><p>Проверяем правильность ссылок с учётом количества столбцов.</p><p>После создания этих столбцов используем их вместо исходных, т. к. в новых столбцах известно местоположение всех чисел по величине.</p><p></p><p>Если речь идёт о повторяющихся и/или неповторяющихся числах, то создаём отдельные столбцы на каждые нужные варианты повторения чисел: на 1 раз (не повторяются), на 2 раза, на 3 раза и т. д. Ограничиваемся только нужными повторениями. Используем комбинацию функций ЕСЛИ и СЧЁТЕСЛИ.</p><p> Пример для 5 чисел и группы на неповторяющиеся числа (начало):</p><p><table class="table"><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th></tr><tr><td>4</td><td>7</td><td>9</td><td>2</td><td>5</td><td>=ЕСЛИ(СЧЁТЕСЛИ($A1:$E1; A1)=1; A1; &quot;&quot;)</td><td>=ЕСЛИ(СЧЁТЕСЛИ($A1:$E1; B1)=1; B1; &quot;&quot;)</td><td>...</td></tr><tr><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td></tr></table> </p><p>Проверяем правильность ссылок с учётом количества столбцов.</p><p>Не забываем после создания столбцов проверять фактическое количество чисел согласно условию задачи. Например:</p><p>=И(СЧЁТ(F1:J1)=3; СЧЁТ(K1:O1)=2)</p><p>Не забываем проверить другие условия, основываясь на созданных группах столбцов, и объединить все условия.</p><p></p><p>Иногда проходит упрощённый вариант, когда нужно проверить только наличие того или иного количества повторяющихся или неповторяющихся чисел, но они не участвуют раздельно в других расчётах. Тогда можно обойтись со столбцами СЧЁТЕСЛИ, которые покажут количества повторений чисел в строке, но не сами числа.</p><p>Пример для 5 чисел (начало):</p><p><table class="table"><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th></tr><tr><td>4</td><td>7</td><td>9</td><td>2</td><td>5</td><td>=СЧЁТЕСЛИ($A1:$E1; A1)=1</td><td>=СЧЁТЕСЛИ($A1:$E1; B1)=1</td><td>...</td></tr><tr><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td></tr></table> </p><p>В этом случае нужно проверить состав этих количеств согласно заданию. Например:</p><p>=И(СЧЁТЕСЛИ(F1:J1; 1)=3; СЧЁТЕСЛИ(K1:O1; 2)=2)</p><p></p><p>Некоторые задания сочетают тему повторений и наибольшего/наименьшего. Для таких заданий может понадобиться создавать и столбцы с отсортированными значениями, и столбцы с повторяющимися/неповторяющимися числами.</p><p></p><p>Если упоминается какое-то число, встречающееся чаще всех остальных, то можно использовать функцию МОДА. Также может быть полезна функция МЕДИАНА.</p><p></p><p>Как правило, нужно найти количество подходящих строк (используем СЧЁТЕСЛИ на последнем столбце с логическими значениями). Может ещё понадобиться найти номер первой или последней подходящей строки.</p></div><div class='page'><a name="ЕГЭ--10._Поиск_текста_14.html"></a><h1 class='title level-2'>10. Поиск текста</h1><br/><p>Сочетание клавиш Ctrl-F - начать поиск. Две главные настройки поиска: “Учитывать регистр” и “Только полные слова”.</p><p></p><p>Обращаем внимание на учёт регистра: с нужно ли искать слова, написанные и со строчной, и с заглавной буквы.</p><p></p><p>Если требуется искать только полные слова, то ставим соответствующий флажок.</p><p>Если требуется искать любое сочетание букв, то не ставим флажок “Только полные слова”.</p><p>Если требуется найти слово во всех формах, то ищем его неизменяемую часть (например, для поиска форм слова “столица” ищем “столиц”) и не ставим флажок “Только полные слова”.</p><p>Если требуется найти сочетание букв, но не как отдельное слово, то выполняем два поиска: сначала без флажка “Только полные слова”, затем с ним, и вычитаем из первого результата второй.</p><p>В сложных словах, пишущихся через дефис, разделённые им части слов текстовый процессор интерпретирует как отдельные слова. Например, в слове “по-видимому” будет найдено отдельное слово “по”. С учётом этого может понадобиться отдельно искать “по-” и “-по” для корректировки ответа.</p><p></p><p>Если поиск нужно осуществлять только по фрагменту текста, то сначала нужно оставить в текстовом документе только этот фрагмент. Для этого удаляем весь текст до начала этого фрагмента и после его окончания. Выделить большой фрагмент для удаления можно так:<ol><li>поставить текстовый курсор на одной границе удаляемого фрагмента;</li><li>поставить текстовый курсор на второй границе удаляемого фрагмента, держа в этот момент нажатой клавишу Shift.</li></ol></p><p></p><p>LibreOffice считает букву “й” буквой “и” с диакритическим знаком. Для корректного поиска сочетаний, содержащих эти буквы, должна быть включена настройка “учитывать диакритику”. В противном случае, например, вместо слова “мой” может быть найдено слово “мои”.</p></div><div class='page'><a name="ЕГЭ--11._Количество_информации_15.html"></a><h1 class='title level-2'>11. Количество информации</h1><br/><p><h1>Алгоритм решения стандартной прямой задачи</h1></p><p>Задача - определить информационный объём некоторого количества объектов.<ol><li>Определяем мощность алфавита. Учитываем возможные заглавные/строчные буквы (x2), десятичные цифры (+10) и т. п.</li><li>Находим число бит на 1 символ (округляем вверх).</li><li>Находим число бит на 1 сообщение (идентификатор пользователя, автомобильный номер, пароль).</li><li>Находим число байт на 1 сообщение (округляем вверх).</li><li>Прибавляем дополнительные данные, если они есть.</li><li>Умножаем результат на число объектов.</li><li>Переводим результат в нужные по условию единицы измерения, если это не байты. 1 килобайт = 1024 байта.</li></ol></p></div><div class='page'><a name="ЕГЭ--12._Исполнитель_с_программой_16.html"></a><h1 class='title level-2'>12. Исполнитель с программой</h1><br/><p><h1>Редактор строк</h1></p><p></p><p><h2>Как решать</h2><ol><li>Берём тестовые (небольшие) данные - из примера, если он есть, или придумываем сами.</li><li>Сами выполняем программу на этих данных.</li><li>Формулируем общий принцип изменения строки, если это возможно.</li><li>Определяем, нужно ли писать программу. Варианты:<ul><li>программа не нужна, результат выражается и вычисляется;</li><li>результат выражается, но подбор ответа делается программой;</li><li>сложные изменения строки, всё делается программой.</li></ul></li></ol></p><p>Стандартные команды Редактора и их аналоги в Python:<ul><li>нашлось(x): x in s;</li><li>заменить(a, b): s = s.replace(a, b, 1)</li></ul></p><p></p><p><h2>Виды заданий</h2><ul><li>Строка сокращается до небольшого числа цифр.</li><li>Одни группы цифр в строке меняются на другие, причём:<ul><li>сумма цифр окончательной строки задана;</li><li>сумма цифр окончательной строки на что-то делится;</li><li>сумма цифр окончательной строки - простое число.</li></ul></li><li>Цифры меняются местами (сортируются).</li></ul></p><p>Программная проверка того, простое ли число s:</p><p><div class="codebox"><pre>[d <span style="color:#a52a2a;font-weight:700">for</span> d <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">2</span>, s) <span style="color:#a52a2a;font-weight:700">if</span> s % d == <span style="color:#ff00ff;font-weight:400">0</span>] == []</pre></div></p><p>или</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">not</span> [d <span style="color:#a52a2a;font-weight:700">for</span> d <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">2</span>, s) <span style="color:#a52a2a;font-weight:700">if</span> s % d == <span style="color:#ff00ff;font-weight:400">0</span>]</pre></div></p></div><div class='page'><a name="ЕГЭ--13._Адресация_в_сети_17.html"></a><h1 class='title level-2'>13. Адресация в сети</h1><br/><p><h1>Принципы адресации</h1><ul><li>IP-адрес:<ul><li>нужен для идентификации устройств (узлов, хостов) в сети;</li><li>это 32-битное число, представимое в виде A.B.C.D, где A, B, C, D - целые числа от 0 до 255;</li><li>пример: 172.16.27.243.</li></ul></li><li>Маска сети (подсети):<ul><li>нужна для определения того, какая часть IP-адреса общая для всех хостов сети, а какая - индивидуальна для каждого хоста;</li><li>имеет тот же формат, что и IP-адрес, но в ней сначала следуют только единицы (общая часть адреса), затем - только нули (индивидуальная часть адреса);</li><li>может также представляться знаком “/” и целым числом - количеством единичных бит в маске;</li><li>пример: 255.255.240.0, или /20.</li><li>из-за того, что в двоичном представлении маски после нулей не могут следовать единицы, в маске могут быть только следующие числа (и не в любом порядке): 0, 128, 192, 224, 240, 248, 252, 254, 255.</li></ul></li><li>Адрес сети:<ul><li>это общая часть адресов всех хостов сети; в индивидуальной части только нули;</li><li>имеет тот же формат, что и IP-адрес;</li><li>получается применением операции побитовой конъюнкции к IP-адресу хоста в сети и маске подсети.</li></ul></li><li>Особые адреса:<ul><li>IP-адрес, в котором индивидуальная часть полностью нулевая, обозначает адрес сети в целом и не может быть адресом какого-либо хоста;</li><li>IP-адрес, в котором индивидуальная часть полностью единичная, обозначает широковещательный (broadcast) адрес в сети и не может быть адресом какого-либо хоста.</li></ul></li><li>Адресная ёмкость сети:<ul><li>определяет максимальное число хостов, которые могут быть в сети.</li><li>определяется количеством бит индивидуальной части IP-адресов, что задаётся маской подсети.</li><li> может быть вычислена по формуле 2<sup>N</sup>-2, где N - количество двоичных единиц в маске подсети.</li></ul></li></ul></p><p></p><p><h1>Вычисления по адресации</h1><ul><li>Все вычисления и рассуждения производятся на основе двоичного представления IP-адресов и масок.</li><li>Хосты принадлежат одной сети при условии, что адреса их сетей совпадают, в противном случае - принадлежат разным сетям.</li><li>По адресу хоста и адресу сети не всегда возможно однозначно определить маску. Может получиться диапазон возможных масок.</li><li>При необходимости работы с несколькими адресами можно использовать функцию, которая возвращает двоичное представление адреса:</p><p></li></ul><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">def</span> <span style="color:#008a8c;font-weight:400">bin_ip</span>(ip):<br />    <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;.&#39;</span>.join([<span style="color:#008a8c;font-weight:400">bin</span>(<span style="color:#008a8c;font-weight:400">int</span>(x))[<span style="color:#ff00ff;font-weight:400">2</span>:].zfill(<span style="color:#ff00ff;font-weight:400">8</span>) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> ip.split(<span style="color:#ff00ff;font-weight:400">&#39;.&#39;</span>)])<br /><span style="color:#008a8c;font-weight:400">print</span>(bin_ip(<span style="color:#ff00ff;font-weight:400">&#39;172.16.27.243&#39;</span>))</pre></div></p><p></p><p><h1>Виды заданий</h1></p><p><h2>Задания без перебора адресов</h2><ul><li>Определить адрес сети по IP-адресу хоста и маске:<ul><li>применяем побитовую конъюнкцию.</li></ul></li><li>Определить маску подсети по IP-адресу хоста и маске подсети:<ul><li>возможных масок может быть несколько; используем уточнение в задании;</li><li>если 1 в адресе хоста остаётся 1 в адресе сети, то в маске точно ещё 1, и всё, что левее в маске, - тоже 1;</li><li>если 1 в адресе хоста превращается в 0 в адресе сети, то в маске точно уже 0, и всё, что правее в маске, - тоже 0;</li><li>между последним сохранившимся единичным битом адреса хоста и первым обнулённым его единичным битом - зона нескольких вариантов маски.</li></ul></li><li>Определить адресную ёмкость сети:<ul><li>определяется по маске подсети;</li><li>если нужно общее число адресов в сети, то 2<sup>N</sup>, где N - количество двоичных единиц в маске подсети;</li><li>если нужно максимальное число хостов, то 2<sup>N</sup>-2, где N - количество двоичных единиц в маске подсети.</li></ul></li><li>Определить маску подсети по двум хостам в одной сети:<ul><li>граница между 1 и 0 в маске - в последнем совпадающем бите адресов или левее.</li></ul></li><li>Определить маску подсети по двум хостам в разных сетях:<ul><li>граница между 1 и 0 в маске - в первом несовпадающем бите адресов или правее.</li></ul></li></ul></p><p></p><p><h2>Задания с перебором адресов</h2><ul><li>Определить маску подсети, элемент маски подсети, элемент IP-адреса хоста или элемент адреса сети:<ul><li>с условием на все адреса сети; например, на определённое количество или соотношение единичных бит.</li></ul></li><li>Определить число хостов в сети по условию на адреса: например, на определённое количество или соотношение единичных бит.</li></ul></p><p></p><p>Если требуется определить количество IP-адресов в сети, удовлетворяющих определённому условию на биты, то их можно посчитать вручную, в том числе с использованием комбинаторных формул (число сочетаний).</p><p>Также можно написать программу с использованием объекта ip_network из модуля itertools. Он позволяет итерироваться по адресам сети и анализировать их двоичное представление.</p><p>Объект ip_network (&quot;сеть&quot;) можно создать указанием IP-адреса сети и маски подсети в виде  A.B.C.D или /N. Вместо адреса сети можно указать и адрес хоста в ней, но тогда нужно использовать значение аргумента strict=False или просто вторым аргументом указать 0.</p><p>Пример программы с перебором адресов сети и анализом их двоичного представления: </p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">ipaddress</span> <span style="color:#a020f0;font-weight:400">import</span> ip_network<br /><span style="color:#0000ff;font-weight:400"># Количество адресов, в которых число двоичных единиц кратно 3</span><br />k = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> ip <span style="color:#a52a2a;font-weight:700">in</span> ip_network(<span style="color:#ff00ff;font-weight:400">&#39;87.156.231.17/255.255.240.0&#39;</span>, <span style="color:#ff00ff;font-weight:400">0</span>):<br />    s = <span style="color:#008a8c;font-weight:400">bin</span>(<span style="color:#008a8c;font-weight:400">int</span>(ip))[<span style="color:#ff00ff;font-weight:400">2</span>:].zfill(<span style="color:#ff00ff;font-weight:400">32</span>)<br />    <span style="color:#a52a2a;font-weight:700">if</span> s.count(<span style="color:#ff00ff;font-weight:400">&#39;1&#39;</span>) % <span style="color:#ff00ff;font-weight:400">3</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        k += <span style="color:#ff00ff;font-weight:400">1</span><br /><span style="color:#008a8c;font-weight:400">print</span>(k)</pre></div></p><p>Если требуется сделать несколько переборов (например, при поиске подходящей маски или элемента адреса сети) под какое-то условие для всех адресов сети, то:<ul><li>используем цикл по подбираемому параметру (часть IP-адреса, часть маски, число единиц в маске;</li><li>создаём сети с учётом параметра с помощью f-строки;</li><li>перебираем IP-адреса и проверяем условие на каждом; если оно ложно, то прерываем перебор и фиксируем, что эта сеть не подходит;</li><li>если сеть подходит, то выводим подобранный параметр;</li><li>если выведены параметры, соответствующие нескольким сетям, то выбираем нужное в соответствии с заданием.</li></ul></p><p>Фиксировать неподходящую сеть и проверять её можно с помощью переменной-флага или с помощью break/else.</p><p>Пример программы с перебором сетей и адресов в них:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">ipaddress</span> <span style="color:#a020f0;font-weight:400">import</span> ip_network<br /><span style="color:#0000ff;font-weight:400"># Сети, в которых у всех адресов число двоичных единиц</span><br /><span style="color:#0000ff;font-weight:400"># в первой половине меньше, чем во второй</span><br /><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">33</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> ip <span style="color:#a52a2a;font-weight:700">in</span> ip_network(f<span style="color:#ff00ff;font-weight:400">&#39;87.56.251.217/{n}&#39;</span>, <span style="color:#ff00ff;font-weight:400">0</span>):<br />        s = <span style="color:#008a8c;font-weight:400">bin</span>(<span style="color:#008a8c;font-weight:400">int</span>(ip))[<span style="color:#ff00ff;font-weight:400">2</span>:].zfill(<span style="color:#ff00ff;font-weight:400">32</span>)<br />        <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#a52a2a;font-weight:700">not</span> (s[:<span style="color:#ff00ff;font-weight:400">16</span>].count(<span style="color:#ff00ff;font-weight:400">&#39;1&#39;</span>) &lt; s[<span style="color:#ff00ff;font-weight:400">16</span>:].count(<span style="color:#ff00ff;font-weight:400">&#39;1&#39;</span>)):<br />            <span style="color:#a52a2a;font-weight:700">break</span><br />    <span style="color:#a52a2a;font-weight:700">else</span>:<br />        <span style="color:#008a8c;font-weight:400">print</span>(n)</pre></div></p><p>Если приходится перебирать элемент маски подсети, то у него могут быть значения только из известного набора, поэтому перебор элементов маски можно делать так:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">for</span> A <span style="color:#a52a2a;font-weight:700">in</span> (<span style="color:#ff00ff;font-weight:400">0</span>, <span style="color:#ff00ff;font-weight:400">128</span>, <span style="color:#ff00ff;font-weight:400">192</span>, <span style="color:#ff00ff;font-weight:400">224</span>, <span style="color:#ff00ff;font-weight:400">240</span>, <span style="color:#ff00ff;font-weight:400">248</span>, <span style="color:#ff00ff;font-weight:400">252</span>, <span style="color:#ff00ff;font-weight:400">254</span>, <span style="color:#ff00ff;font-weight:400">255</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> ip <span style="color:#a52a2a;font-weight:700">in</span> ip_network(f<span style="color:#ff00ff;font-weight:400">&#39;87.56.251.217/255.255.{A}.0&#39;</span>, <span style="color:#ff00ff;font-weight:400">0</span>):</pre></div></p><p>Если приходится перебирать элемент IP-адреса, то его перебор можно делать так:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">for</span> A <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">256</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> ip <span style="color:#a52a2a;font-weight:700">in</span> ip_network(f<span style="color:#ff00ff;font-weight:400">&#39;87.56.A.217/255.255.240.0&#39;</span>, <span style="color:#ff00ff;font-weight:400">0</span>):</pre></div></p></div><div class='page'><a name="ЕГЭ--14._Системы_счисления_18.html"></a><h1 class='title level-2'>14. Системы счисления</h1><br/><p><h1>Задано выражение с большими числами и степенями</h1></p><p>Если нужно найти количество некоторых цифр в записи результата выражения в некоторой системе счисления, то пишем программу для вычисления значения выражения и как бы для получения записи результата в нужной системе счисления. </p><p>Общий пример программы, подсчитывающей остатки от деления:</p><p><div class="codebox"><pre>n = ВЫРАЖЕНИЕ <br />k = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> n &gt; <span style="color:#ff00ff;font-weight:400">0</span>: <br />    <span style="color:#a52a2a;font-weight:700">if</span> n % ОСНОВАНИЕ == ЦИФРА: <br />        k += <span style="color:#ff00ff;font-weight:400">1</span> <br />    <span style="color:#008a8c;font-weight:400">print</span>(n % ОСНОВАНИЕ, end=<span style="color:#ff00ff;font-weight:400">&#39;&#39;</span>) <br />    n //= ОСНОВАНИЕ <br /><span style="color:#008a8c;font-weight:400">print</span>() <br /><span style="color:#008a8c;font-weight:400">print</span>(k)</pre></div></p><p>Общий пример программы, формирующей явное представление значения выражения в строке; применимо для оснований систем счисления до 16:</p><p><div class="codebox"><pre>n = ВЫРАЖЕНИЕ <br />s = <span style="color:#ff00ff;font-weight:400">&#39;&#39;</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> n &gt; <span style="color:#ff00ff;font-weight:400">0</span>: <br />    s = <span style="color:#008a8c;font-weight:400">str</span>(n % ОСНОВАНИЕ) + s <br />    n //= ОСНОВАНИЕ <br /><span style="color:#008a8c;font-weight:400">print</span>(s)<br /><span style="color:#008a8c;font-weight:400">print</span>(s.count(<span style="color:#ff00ff;font-weight:400">&#39;ЦИФРА&#39;</span>))</pre></div></p><p>Общий пример программы, формирующей статистику по частоте всех цифр:</p><p><div class="codebox"><pre>n = ВЫРАЖЕНИЕ <br />s = [<span style="color:#ff00ff;font-weight:400">0</span>] * ОСНОВАНИЕ <br /><span style="color:#a52a2a;font-weight:700">while</span> n &gt; <span style="color:#ff00ff;font-weight:400">0</span>: <br />    s[n % ОСНОВАНИЕ] += <span style="color:#ff00ff;font-weight:400">1</span> <br />    n //= ОСНОВАНИЕ <br /><span style="color:#008a8c;font-weight:400">print</span>(s)</pre></div></p><p></p><p>Если нужно найти сумму цифр в записи результата выражения в некоторой системе счисления, то также пишем программу для вычисления значения выражения и как бы для получения записи результата в нужной системе счисления.</p><p>Общий пример программы, подсчитывающей остатки от деления:</p><p><div class="codebox"><pre>n = ПРИМЕР <br />s = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> n &gt; <span style="color:#ff00ff;font-weight:400">0</span>: <br />    s += n % ОСНОВАНИЕ<br />    <span style="color:#008a8c;font-weight:400">print</span>(n % ОСНОВАНИЕ, end=<span style="color:#ff00ff;font-weight:400">&#39;&#39;</span>) <br />    n //= ОСНОВАНИЕ <br /><span style="color:#008a8c;font-weight:400">print</span>()<br /><span style="color:#008a8c;font-weight:400">print</span>(s)</pre></div></p><p>Общий пример программы, формирующей явное представление значения выражения в строке; применимо для оснований систем счисления до 16:</p><p><div class="codebox"><pre>n = ПРИМЕР <br />s = <span style="color:#ff00ff;font-weight:400">&#39;&#39;</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> n &gt; <span style="color:#ff00ff;font-weight:400">0</span>: <br />    s = <span style="color:#008a8c;font-weight:400">str</span>(n % ОСНОВАНИЕ) + s <br />    n //= ОСНОВАНИЕ <br /><span style="color:#008a8c;font-weight:400">print</span>(s)<br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#008a8c;font-weight:400">sum</span>([<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> s]))</pre></div></p><p></p><p><h1>Задано выражение с неизвестной цифрой</h1></p><p>Пишем программу перебора цифр с вычислением и проверкой значения выражения.</p><p>Пример программы с циклом по числовым значениям цифры, с использованием f-строк, функции int; применимо для оснований систем счисления до 16:</p><p><div class="codebox"><pre>b = <span style="color:#ff00ff;font-weight:400">14</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(b): <br />    x = <span style="color:#008a8c;font-weight:400">hex</span>(n)[<span style="color:#ff00ff;font-weight:400">2</span>:] <br />    s = <span style="color:#008a8c;font-weight:400">int</span>(f<span style="color:#ff00ff;font-weight:400">&#39;12{x}34&#39;</span>, b) + <span style="color:#008a8c;font-weight:400">int</span>(f<span style="color:#ff00ff;font-weight:400">&#39;5{x}678&#39;</span>, b) <br />    <span style="color:#a52a2a;font-weight:700">if</span> s % <span style="color:#ff00ff;font-weight:400">17</span> == <span style="color:#ff00ff;font-weight:400">0</span>: <br />        <span style="color:#008a8c;font-weight:400">print</span>(n, s // <span style="color:#ff00ff;font-weight:400">17</span>)</pre></div></p><p>Пример программы с циклам по всем цифрам как символам, c использованием f-строк, функции int; применимо для оснований систем счисления до 36:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#ff00ff;font-weight:400">&#39;0123456789abcde&#39;</span>: <br />    s = <span style="color:#008a8c;font-weight:400">int</span>(f<span style="color:#ff00ff;font-weight:400">&#39;12{x}34&#39;</span>, b) + <span style="color:#008a8c;font-weight:400">int</span>(f<span style="color:#ff00ff;font-weight:400">&#39;5{x}678&#39;</span>, b) <br />    <span style="color:#a52a2a;font-weight:700">if</span> s % <span style="color:#ff00ff;font-weight:400">17</span> == <span style="color:#ff00ff;font-weight:400">0</span>: <br />        <span style="color:#008a8c;font-weight:400">print</span>(x, s // <span style="color:#ff00ff;font-weight:400">17</span>)</pre></div></p><p>Пример программы с циклом по числовым значениям цифр, с разложением числа по степеням; применимо для любых оснований систем счисления:</p><p><div class="codebox"><pre>b = <span style="color:#ff00ff;font-weight:400">143</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(b): <br />    s = ((((<span style="color:#ff00ff;font-weight:400">1</span>*b+<span style="color:#ff00ff;font-weight:400">2</span>)*b+x)*b+<span style="color:#ff00ff;font-weight:400">3</span>)*b+<span style="color:#ff00ff;font-weight:400">4</span>) + ((((<span style="color:#ff00ff;font-weight:400">5</span>*b+x)*b+<span style="color:#ff00ff;font-weight:400">6</span>)*b+<span style="color:#ff00ff;font-weight:400">7</span>)*b+<span style="color:#ff00ff;font-weight:400">8</span>) <br />    <span style="color:#a52a2a;font-weight:700">if</span> s % <span style="color:#ff00ff;font-weight:400">17</span> == <span style="color:#ff00ff;font-weight:400">0</span>: <br />        <span style="color:#008a8c;font-weight:400">print</span>(x, s // <span style="color:#ff00ff;font-weight:400">17</span>)</pre></div></p><p>Пример программы с циклом по числовым значениям цифр, с разложением числа по схеме Горнера; применимо для любых оснований систем счисления:</p><p><div class="codebox"><pre>b = <span style="color:#ff00ff;font-weight:400">143</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(b): <br />    s = (<span style="color:#ff00ff;font-weight:400">1</span>*b**<span style="color:#ff00ff;font-weight:400">4</span>+<span style="color:#ff00ff;font-weight:400">2</span>*b**<span style="color:#ff00ff;font-weight:400">3</span>+x*b**<span style="color:#ff00ff;font-weight:400">2</span>+<span style="color:#ff00ff;font-weight:400">3</span>*b+<span style="color:#ff00ff;font-weight:400">4</span>) + (<span style="color:#ff00ff;font-weight:400">5</span>*b**<span style="color:#ff00ff;font-weight:400">4</span>+x*b**<span style="color:#ff00ff;font-weight:400">3</span>+<span style="color:#ff00ff;font-weight:400">6</span>*b**<span style="color:#ff00ff;font-weight:400">2</span>+<span style="color:#ff00ff;font-weight:400">7</span>*b+<span style="color:#ff00ff;font-weight:400">8</span>) <br />    <span style="color:#a52a2a;font-weight:700">if</span> s % <span style="color:#ff00ff;font-weight:400">17</span> == <span style="color:#ff00ff;font-weight:400">0</span>: <br />        <span style="color:#008a8c;font-weight:400">print</span>(x, s // <span style="color:#ff00ff;font-weight:400">17</span>)</pre></div></p></div><div class='page'><a name="ЕГЭ--15._Логическое_выражение_19.html"></a><h1 class='title level-2'>15. Логическое выражение</h1><br/><p><h1>Подбор параметра</h1></p><p></p><p><h2>Виды заданий</h2><ul><li>делимость</li><li>побитовая конъюнкция</li><li>неравенства, в том числе с двумя и тремя независимыми переменными</li><li>множества</li><li>отрезки</li><li>сочетания тем</li></ul></p><p></p><p><h2>Как решать</h2></p><p>Общий алгоритм решения заданий различных типов:</p><p>0. Если задание о действительных числах и отрезках, то изображаем схематично отрезки на числовой оси.<ol><li>Переписываем заданное логическое выражение в упрощённом виде.</li><li>Упрощаем выражение. При необходимости применяем:<ol><li>преобразование импликации к дизъюнкции: a→b = ¬a∨b</li><li>правила де Моргана: ¬(a∨b) = ¬a∧¬b, ¬(a∧b) = ¬a∨¬b</li></ol></li><li>Определяем, для каких значений независимых переменных “всё хорошо”, т. е. выражение и так принимает нужное значение даже без учёта параметра.</li><li>Определяем, для каких значений независимых переменных “всё плохо”, т. е. выражение не принимает нужное значение без параметра, и параметр надо находить.</li><li>Находим значение параметра под нужные значения независимых переменных.</li></ol></p><p></p><p><h2>Решение программой</h2></p><p>Если параметр и независимые переменные могут принимать только целочисленные значения, то можно написать программу, определяющую значения параметра путём перебора. Перебираются значения параметра, и при каждом значении параметра перебираются значения независимых переменных с проверкой значения выражения. Если для всех значений независимых переменных выражение принимает нужное значение, то значение параметра считается подходящим.</p><p></p><p>Варианты проверки некоторых из возможных элементов выражения:<ul><li>делимость - ДЕЛ(x, 15): x % 15 == 0;</li><li>побитовая конъюнкция - x &amp; 27 = 0: x &amp; 27 == 0;</li><li>неравенства: 2*x+4*y&lt;=45;</li><li>принадлежность отрезку: 10 &lt;= x &lt;= 40.</li></ul></p><p></p><p>Если независимые переменные могут принимать вещественные значения, то целочисленный перебор может дать неверные результаты. Например, между двумя соседними целочисленными значениями независимой переменной, для которых значение выражения истинно, может оказаться нецелое значение, для которого значение выражения ложно. Написание программы, учитывающей это, возможно, но затруднено.</p><p></p><p>Получив ответ с помощью программы, стоит увеличить пределы перебора значений параметра и независимых переменных и запустить программу ещё раз. Анализ выражения может указать на необходимые пределы перебора.</p><p></p><p>Пример программы с одной независимой переменной:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">for</span> A <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#ff00ff;font-weight:400">100</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#ff00ff;font-weight:400">100</span>):<br />        <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#a52a2a;font-weight:700">not</span> (((x &amp; A == <span style="color:#ff00ff;font-weight:400">0</span>) &lt;= (x &amp; <span style="color:#ff00ff;font-weight:400">26</span> == <span style="color:#ff00ff;font-weight:400">0</span>)) <span style="color:#a52a2a;font-weight:700">or</span> <span style="color:#a52a2a;font-weight:700">not</span> (x &amp; <span style="color:#ff00ff;font-weight:400">10</span> == <span style="color:#ff00ff;font-weight:400">0</span>)):<br />            <span style="color:#a52a2a;font-weight:700">break</span><br />    <span style="color:#a52a2a;font-weight:700">else</span>:<br />        <span style="color:#008a8c;font-weight:400">print</span>(A)<br />        <span style="color:#a52a2a;font-weight:700">break</span></pre></div></p><p>Пример программы с двумя независимыми переменными:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">for</span> A <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#ff00ff;font-weight:400">1000</span>):<br />    ok = <span style="color:#ff00ff;font-weight:400">True</span><br />    <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#ff00ff;font-weight:400">100</span>):<br />        <span style="color:#a52a2a;font-weight:700">for</span> y <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#ff00ff;font-weight:400">100</span>):<br />            <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#a52a2a;font-weight:700">not</span> ((x + <span style="color:#ff00ff;font-weight:400">5</span> * y &gt;= <span style="color:#ff00ff;font-weight:400">67</span>) <span style="color:#a52a2a;font-weight:700">or</span> (<span style="color:#ff00ff;font-weight:400">3</span> * x + <span style="color:#ff00ff;font-weight:400">2</span> * y &lt; A)):<br />                ok = <span style="color:#ff00ff;font-weight:400">False</span><br />                <span style="color:#a52a2a;font-weight:700">break</span><br />        <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#a52a2a;font-weight:700">not</span> ok:<br />            <span style="color:#a52a2a;font-weight:700">break</span><br />    <span style="color:#a52a2a;font-weight:700">if</span> ok:<br />        <span style="color:#008a8c;font-weight:400">print</span>(A)<br />        <span style="color:#a52a2a;font-weight:700">break</span></pre></div></p></div><div class='page'><a name="ЕГЭ--16._Рекурсия_20.html"></a><h1 class='title level-2'>16. Рекурсия</h1><br/><p><h1>Вычисление значений функции</h1></p><p>Если формулы функции несложные, а числа не очень большие, то ответ можно получить написанием программы или созданием таблицы значений функции в табличном процессоре.</p><p></p><p>Если числа большие, то:<ol><li>выводим закономерность (факториал, степень и т. п.), либо выражаем одни значения функции через другие;</li><li>упрощаем выражение;</li><li>вычисляем результат.</li></ol></p><p></p><p>Некоторые задания с большими числами также решаются с помощью программы с рекурсивной функцией, но при большой глубине рекурсии нужно ослабить ограничение в интерпретаторе, повысив лимит рекурсии:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">sys</span> <span style="color:#a020f0;font-weight:400">import</span> setrecursionlimit<br /><br />setrecursionlimit(<span style="color:#ff00ff;font-weight:400">5000</span>)</pre></div> </p><p>Лимит рекурсии нужно повышать постепенно.</p></div><div class='page'><a name="ЕГЭ--17._Обработка_массива_чисел_21.html"></a><h1 class='title level-2'>17. Обработка массива чисел</h1><br/><p><h1>Как решать</h1><ol><li>Открываем файл, считываем числа в список.</li><li>Проходом по массиву ищем нужный элемент.</li><li>Проходом по массиву ищем нужные пары (тройки).</li></ol></p><p>При открытии файла первым числом может быть количество элементов последовательности. Его можно проигнорировать следующими способами:<ul><li>предварительное f.readline() перед чтением списка;</li><li>удаление первого элемента списка:<ul><li>del a[0];</li><li>a.pop(0);</li><li>a = a[1:].</li></ul></li></ul></p><p></p><p><h1>Варианты формулировок условий</h1><ul><li>максимальное/минимальное: для начальных значений можно использовать float(&#39;-inf&#39;) или float(&#39;inf&#39;) соответственно;</li><li>условия, связанные с делимостью и остатками:<ul><li>элемент делится на x: a[i] % x == 0;</li><li>элемент не делится на x: a[i] % x != 0;</li><li>элемент при делении на x даёт остаток y: abs(a[i]) % x == y (помним про остатки отрицательных чисел);</li><li>элемент в десятичной записи заканчивается на цифру x: abs(a[i]) % 10 == x (помним про остатки отрицательных чисел);</li></ul></li><li>условия на количество цифр (двузначное, трёхзначное...); варианты проверки:<ul><li>len(str(a[i])) == 3 (помним про знак “-” у отрицательных чисел);</li><li>100 &lt;= a[i] &lt;= 999;</li><li>a[i] in range(100, 1000).</li></ul></li><li>условия на положительность/отрицательность, включая нестрогие условия;</li><li>условия на то, что один элемент больше/меньше другого, включая нестрогие условия;</li><li>составление общего условия из частных:<ul><li>“оба элемента / все элементы соответствуют условию” (and);</li><li>“хотя бы один элемент соответствует условию” (or);</li><li>“ровно один элемент соответствует условию” (!=, ^);</li><li>помним про приоритет операций, ставим скобки для верности;</li><li>тройки элементов, “не менее / не более / ровно N элементов соответствуют условию” - предпочитаем счётчик элементов дленноу условию.</li></ul></li></ul></p><p></p><p><h1>На что ещё обратить внимание</h1></p><p>Внимательно читаем и чётко понимаем каждое слово в задании.</p><p>В ответе должны быть два числа:<ul><li>число подходящих пар (троек);</li><li>что-нибудь ещё про <strong>эти</strong> пары (тройки).</li></ul></p><p>В сложных случаях пробуем выполнить программу на своих подготовленных тестовых данных.</p></div><div class='page'><a name="ЕГЭ--18._Динамическое_программирование_22.html"></a><h1 class='title level-2'>18. Динамическое программирование</h1><br/><p><h1>Робот и монеты</h1></p><p></p><p><h2>Движение из угла в угол</h2><ul><li>Могут быть стены.</li><li>Могут быть углы. Условие может допускать как все углы как финальные клетки, так и только “основной”.</li></ul></p><p></p><p><h2>Как решать</h2><ol><li>Раскрашиваем всё поле и особые клетки (у стен, за стенами по ходу движения Робота).</li><li>Делаем копию формата поля.</li><li>Заполняем копию поля общей формулой.</li><li>Меняем формулы в особенных клетках.</li><li>Учитываем разные углы (финальные клетки), если необходимо. </li><li>После получения максимального значения минимальное можно получить заменой во всех формулах МАКС на МИН: сочетание клавиш Ctrl-H открывает окно замены, нужно выбрать область поиска - формулы.</li></ol></p></div><div class='page'><a name="ЕГЭ--19-21._Выигрышная_стратегия_23.html"></a><h1 class='title level-2'>19-21. Выигрышная стратегия</h1><br/><p><h1>Основные идеи</h1><ul><li>В любой ситуации у одного из игроков есть выигрышная стратегия (ВС).</li><li>Все позиции делятся на две категории:<ul><li>“+” (ВС у того, кто в ней ходит);</li><li>“-” (ВС не у того, кто в ней ходит).</li></ul></li><li>Выигранная позиция считается позицией “-” (для того, чей в ней мог быть ход).</li><li>Проигранная позиция считается позицией “+&quot; (для того, чей в ней мог быть ход).</li><li>Если из позиции все ходы ведут в “+”, то она сама - “-”.</li><li>Если из позиции есть ход в “-”, то она сама - “+”.</li><li>Идём от окончательных позиций назад по ходу игры, отмечаем позиции “+” и “-”.</li></ul></p><p></p><p><h1>Программа</h1></p><p>Пример программы для игры с 1 кучей камней:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">functools</span> <span style="color:#a020f0;font-weight:400">import</span> lru_cache <br /><br /><span style="color:#a52a2a;font-weight:700">def</span> <span style="color:#008a8c;font-weight:400">n</span>(p): <br />    <span style="color:#a52a2a;font-weight:700">return</span> p + <span style="color:#ff00ff;font-weight:400">1</span>, p * <span style="color:#ff00ff;font-weight:400">2</span> <br /><br /><span style="color:#a020f0;font-weight:400">@lru_cache</span>(<span style="color:#ff00ff;font-weight:400">None</span>) <br /><span style="color:#a52a2a;font-weight:700">def</span> <span style="color:#008a8c;font-weight:400">res</span>(p): <br />    <span style="color:#a52a2a;font-weight:700">if</span> p &gt;= <span style="color:#ff00ff;font-weight:400">100</span>: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;Lose&#39;</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> p &gt;= <span style="color:#ff00ff;font-weight:400">70</span>: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;Win&#39;</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">any</span>(res(x) == <span style="color:#ff00ff;font-weight:400">&#39;Win&#39;</span> <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> n(p)): <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;P1&#39;</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">all</span>(res(x) <span style="color:#a52a2a;font-weight:700">in</span> (<span style="color:#ff00ff;font-weight:400">&#39;P1&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;Lose&#39;</span>) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> n(p)): <span style="color:#0000ff;font-weight:400"># any, если Петя поддаётся/ошибается</span><br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;V1&#39;</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">any</span>(res(x) == <span style="color:#ff00ff;font-weight:400">&#39;V1&#39;</span> <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> n(p)): <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;P2&#39;</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">all</span>(res(x) <span style="color:#a52a2a;font-weight:700">in</span> (<span style="color:#ff00ff;font-weight:400">&#39;P1&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;P2&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;Lose&#39;</span>) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> n(p)): <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;V2&#39;</span> <br /><br /><span style="color:#a52a2a;font-weight:700">for</span> p <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#ff00ff;font-weight:400">70</span>): <br />    r = res(p) <br />    <span style="color:#a52a2a;font-weight:700">if</span> r != <span style="color:#ff00ff;font-weight:400">None</span>: <br />        <span style="color:#008a8c;font-weight:400">print</span>(p, r) </pre></div></p><p>Пример программы для игры с 2 кучами камней:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">functools</span> <span style="color:#a020f0;font-weight:400">import</span> lru_cache <br /><br /><span style="color:#a52a2a;font-weight:700">def</span> <span style="color:#008a8c;font-weight:400">n</span>(p): <br />    a, b = p <br />    <span style="color:#a52a2a;font-weight:700">return</span> (a + <span style="color:#ff00ff;font-weight:400">1</span>, b), (a * <span style="color:#ff00ff;font-weight:400">2</span>, b), (a, b + <span style="color:#ff00ff;font-weight:400">1</span>), (a, b * <span style="color:#ff00ff;font-weight:400">2</span>) <br /><br /><span style="color:#a020f0;font-weight:400">@lru_cache</span>(<span style="color:#ff00ff;font-weight:400">None</span>) <br /><span style="color:#a52a2a;font-weight:700">def</span> <span style="color:#008a8c;font-weight:400">res</span>(p): <br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">sum</span>(p) &gt;= <span style="color:#ff00ff;font-weight:400">70</span>: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;Win&#39;</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">any</span>(res(x) == <span style="color:#ff00ff;font-weight:400">&#39;Win&#39;</span> <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> n(p)): <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;P1&#39;</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">all</span>(res(x) == <span style="color:#ff00ff;font-weight:400">&#39;P1&#39;</span> <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> n(p)): <span style="color:#0000ff;font-weight:400"># any, если Петя поддаётся/ошибается </span><br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;V1&#39;</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">any</span>(res(x) == <span style="color:#ff00ff;font-weight:400">&#39;V1&#39;</span> <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> n(p)): <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;P2&#39;</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">all</span>(res(x) <span style="color:#a52a2a;font-weight:700">in</span> (<span style="color:#ff00ff;font-weight:400">&#39;P1&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;P2&#39;</span>) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> n(p)): <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">&#39;V2&#39;</span> <br /><br /><span style="color:#a52a2a;font-weight:700">for</span> p <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#ff00ff;font-weight:400">62</span>): <br />    r = res((<span style="color:#ff00ff;font-weight:400">8</span>, p)) <br />    <span style="color:#a52a2a;font-weight:700">if</span> r != <span style="color:#ff00ff;font-weight:400">None</span>: <br />        <span style="color:#008a8c;font-weight:400">print</span>(p, r) </pre></div></p><p></p><p>В Python, начаная с версии 3.9, доступна функция cache, которую можно использовать вместо lru_cache и без аргумента (None).</p></div><div class='page'><a name="ЕГЭ--22._Процессы_24.html"></a><h1 class='title level-2'>22. Процессы</h1><br/><p><h1>Виды заданий</h1><ul><li>Предполагающие как можно более раннее выполнение каждого процесса:<ul><li>определение самого раннего времени завершения всех процессов;</li><li>определение самого раннего времени завершения некоторого количества процессов;</li><li>определение максимального числа процессов, которые успеют завершиться к заданному времени;</li><li>определение неизвестного параметра процесса, если известно самое раннее время завершения всех процессов:<ul><li>неизвестное время выполнения;</li><li>зависимость от неизвестного процесса.</li></ul></li></ul></li><li>Не предполагающие как можно более раннего выполнения каждого процесса:<ul><li>определение максимальной продолжительности непрерывного отрезка времени, в течение которого возможно одновременное выполнение некоторого числа процессов.</li></ul></li></ul></p><p></p><p><h1>Как решать</h1></p><p><h2>Задания с наиболее ранним выполнением каждого процесса</h2></p><p>Если речь не идёт об одновременном выполнении какого-либо количества процессов, то решать стоит в таблице с данными о процессах.</p><p>Для каждого процесса будем определять время его наиболее раннего завершения, считая от начала выполнения всей совокупности процессов. В таблице для этого можно создать отдельный столбец.</p><p>Это время определяется так:<ul><li>для независимого процесса оно равно времени его выполнения, т. к. выполнение такого процесса можно начать сразу же;</li><li>для зависимого процесса оно равно максимальному из значений этого времени у всех процессов, от которых непосредственно зависит данный процесс, плюс его время выполнения, т. к. выполнение такого процесса можно начать только после того, как завершится последний из влияющих на него процессов.</li></ul></p><p>Пример вычислений этого столбца в таблице:</p><p><table class="table"><tr><th> </th><th>A</th><th>B</th><th>C</th><th>D</th></tr><tr><td>1</td><td>ID процесса</td><td>Время выполнения</td><td>Зависимости</td><td>Время завершения</td></tr><tr><td>2</td><td>1</td><td>6</td><td>0</td><td>=B2</td></tr><tr><td>3</td><td>2</td><td>9</td><td>0</td><td>=B3</td></tr><tr><td>4</td><td>3</td><td>4</td><td>1</td><td>=D2+B4</td></tr><tr><td>5</td><td>4</td><td>5</td><td>1; 2</td><td>=МАКС(D2; D3)+B5</td></tr><tr><td>6</td><td>5</td><td>8</td><td>1; 3; 4</td><td>=МАКС(D2; D4; D5)+B6</td></tr></table></p><p>Если не предполагается определение независимого параметра, то вместо формул можно выполнять вычисления самостоятельно и вписывать в ячейки таблицы сразу результаты.</p><p></p><p>Как получаются ответы:<ul><li>самое раннее время завершения всех процессов: максимальное значение в столбце времени завершения;</li><li>самое раннее время завершения некоторого количества процессов: копирование на другой лист значений столбца времени завершения (вставка именно значений, а не формул), их сортировка по возрастанию и определение значения на соответствующем месте отсортированного списка;</li><li>определение максимального числа процессов, которые успеют завершиться за заданное время: использование функции СЧЁТЕСЛИ с условием “меньше или равно” на столбце времени завершения либо иначе - копирование значений на другой лист и сортировка.</li></ul></p><p></p><p><strong>Если требуется определить время выполнения одного процесса</strong>, то вместо неизвестного значения можно подставить любое значение и затем подбирать правильное значение времени выполнения. При нём общее время выполнения всех процессов должно совпасть с заданным.</p><p></p><p><strong>Если требуется определить неизвестную зависимость процесса</strong>, то используем отдельную ячейку как “время завершения какого-то процесса” и используем её в формуле вместо искомой, а затем подбираем её правильное значение. При искомом значении общее время выполнения всех процессов должно совпасть с заданным. Затем определяем, с временем завершения какого процесса совпадает найденное значение.</p><p></p><p><strong>Если требуется определить максимально продолжительное одновременное выполнение процессов (при условии раннего их завершения)</strong>, то вместо вычислений в отдельном столбце таблицы нужно построить имитацию диаграммы Ганта:<ol><li>пронумеровать последующие столбцы в табличном процессоре согласно количеству секунд, необходимому для выполнения всех процессов;</li><li>для каждого процесса в его строке создать последовательность единиц в ячейках, соответствующих периоду его самого раннего выполнения (с учётом зависимостей);</li><li>создать итоговую строку с суммарным выполнением процессов за каждую секунда (сумма по каждому столбцу);</li><li>в итоговой строке определить максимальное значение и самую длинную непрервыную последовательность таких значений.</li></ol></p><p></p><p><h2>Задания на максимально продолжительное одновременное выполнение процессов (без условий раннего завершения)</h2></p><p>Решение, не основанное на полном переборе вариантов, применимо для ситуаций, когда больше заданного числа процессов не может выполняться вообще (число одновременно исполняемых ветвей не превышает требуемое, нет “лишних” ветвей).</p><p>Алгоритм решения:<ol><li>Строим графическую схему процессов, с зависимостями и продолжительностью выполнения каждого процесса.</li><li>Предварительно обращаем внимание на ветки одновременного выполнения для дальнейшего выбора процессов в них.</li><li>Исключаем процессы, которые не могут принимать участие в одновременном выполнении нужного числа процессов. Это те процессы, только после которых произошли необходимые разветвления и те, уже до которых произошли слияния нужных ветвей.</li><li>Объединяем последовательные процессы без разветвлений и слияний в одну непрерывную серию.</li><li>Объединяем последовательные процессы в конце серии процессов, даже если есть разветвление, но следующий процесс больше ни от чего не зависит.</li><li>Получаем ответ как наименьшее время выполнения серии среди ветвей.</p><p></li></ol></p></div><div class='page'><a name="ЕГЭ--23._Количество_программ_25.html"></a><h1 class='title level-2'>23. Количество программ</h1><br/><p>Если чисел, которые можно получить в ходе выполнения программы, немного, то можно решить письменно, вычислениями по рекуррентной формуле.</p><p></p><p>Если чисел, которые можно получить в ходе выполнения программы, много, но среди действий есть только сложения и вычитания фиксированных значений, то можно решить в табличном процессоре.</p><p></p><p>Если чисел, которые можно получить в ходе выполнения программы, много, и есть умножения, деления, более сложные изменения и т. п., то пишем программу.</p><p></p><p>Пример программы с решением через рекурсивную функцию с одним аргументом (не универсально, надо проверять делимость):</p><p><div class="codebox"><pre><span style="color:#0000ff;font-weight:400"># Команды: +1, *2. </span><br /><span style="color:#0000ff;font-weight:400"># Найти число программ: 2 -&gt; 17 </span><br /><br /><span style="color:#a52a2a;font-weight:700">def</span> <span style="color:#008a8c;font-weight:400">f</span>(n): <br />    <span style="color:#a52a2a;font-weight:700">if</span> n &lt; <span style="color:#ff00ff;font-weight:400">2</span>: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">0</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> n == <span style="color:#ff00ff;font-weight:400">2</span>: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">1</span> <br />    t = f(n - <span style="color:#ff00ff;font-weight:400">1</span>) <br />    <span style="color:#a52a2a;font-weight:700">if</span> n % <span style="color:#ff00ff;font-weight:400">2</span> == <span style="color:#ff00ff;font-weight:400">0</span>: <br />        t += f(n // <span style="color:#ff00ff;font-weight:400">2</span>) <br />    <span style="color:#a52a2a;font-weight:700">return</span> t <br /><br /><span style="color:#008a8c;font-weight:400">print</span>(f(<span style="color:#ff00ff;font-weight:400">17</span>))</pre></div></p><p>Пример программы с решением через рекурсивную функцию с двумя аргументами (универсально):</p><p><div class="codebox"><pre><span style="color:#0000ff;font-weight:400"># Команды: +1, *2. </span><br /><span style="color:#0000ff;font-weight:400"># Найти число программ: 2 -&gt; 17</span><br /><br /><span style="color:#a52a2a;font-weight:700">def</span> <span style="color:#008a8c;font-weight:400">f</span>(a, b): <br />    <span style="color:#a52a2a;font-weight:700">if</span> a &gt; b: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">0</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> a == b: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">1</span> <br />    <span style="color:#a52a2a;font-weight:700">return</span> f(a + <span style="color:#ff00ff;font-weight:400">1</span>, b) + f(a * <span style="color:#ff00ff;font-weight:400">2</span>, b)<br /><br /><span style="color:#008a8c;font-weight:400">print</span>(f(<span style="color:#ff00ff;font-weight:400">2</span>, <span style="color:#ff00ff;font-weight:400">17</span>))</pre></div></p><p>Пример программы с решением через рекурсивную функцию и запретом прохода через определённое число:</p><p><div class="codebox"><pre><span style="color:#0000ff;font-weight:400"># Команды: +1, *2. </span><br /><span style="color:#0000ff;font-weight:400"># Найти число программ: 2 -&gt; 17, без 7 </span><br /><br /><span style="color:#a52a2a;font-weight:700">def</span> <span style="color:#008a8c;font-weight:400">f</span>(a, b): <br />    <span style="color:#a52a2a;font-weight:700">if</span> a &gt; b <span style="color:#a52a2a;font-weight:700">or</span> a == <span style="color:#ff00ff;font-weight:400">7</span>: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">0</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> a == b: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">1</span> <br />    <span style="color:#a52a2a;font-weight:700">return</span> f(a + <span style="color:#ff00ff;font-weight:400">1</span>, b) + f(a * <span style="color:#ff00ff;font-weight:400">2</span>, b) <br /><br /><span style="color:#008a8c;font-weight:400">print</span>(f(<span style="color:#ff00ff;font-weight:400">2</span>, <span style="color:#ff00ff;font-weight:400">17</span>))</pre></div></p><p>Пример программы с решением через рекурсивную функцию и обязательным проходом через определённое число (используется комбинаторное правило умножения):</p><p><div class="codebox"><pre><span style="color:#0000ff;font-weight:400"># Команды: +1, *2. </span><br /><span style="color:#0000ff;font-weight:400"># Найти число программ: 2 -&gt; 17, через 7 </span><br /><br /><span style="color:#a52a2a;font-weight:700">def</span> <span style="color:#008a8c;font-weight:400">f</span>(a, b): <br />    <span style="color:#a52a2a;font-weight:700">if</span> a &gt; b: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">0</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> a == b: <br />        <span style="color:#a52a2a;font-weight:700">return</span> <span style="color:#ff00ff;font-weight:400">1</span> <br />    <span style="color:#a52a2a;font-weight:700">return</span> f(a + <span style="color:#ff00ff;font-weight:400">1</span>, b) + f(a * <span style="color:#ff00ff;font-weight:400">2</span>, b) <br /><br /><span style="color:#008a8c;font-weight:400">print</span>(f(<span style="color:#ff00ff;font-weight:400">2</span>, <span style="color:#ff00ff;font-weight:400">7</span>) * f(<span style="color:#ff00ff;font-weight:400">7</span>, <span style="color:#ff00ff;font-weight:400">17</span>))</pre></div></p><p>Дополнительный способ для случаев с обязательным проходом через число: разница результата без учёта этого числа и результата с запретом прохода через это число.</p><p></p><p>Пример программы с решением через якобы “функцию” (на самом деле список):</p><p><div class="codebox"><pre><span style="color:#0000ff;font-weight:400"># Команды: +1, *2. </span><br /><span style="color:#0000ff;font-weight:400"># Найти число программ: 2 -&gt; 17 </span><br /><br />f = [<span style="color:#ff00ff;font-weight:400">0</span>] * <span style="color:#ff00ff;font-weight:400">18</span> <br />f[<span style="color:#ff00ff;font-weight:400">2</span>] = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">3</span>, <span style="color:#ff00ff;font-weight:400">18</span>): <br />    t = f[n - <span style="color:#ff00ff;font-weight:400">1</span>] <br />    <span style="color:#a52a2a;font-weight:700">if</span> n % <span style="color:#ff00ff;font-weight:400">2</span> == <span style="color:#ff00ff;font-weight:400">0</span>: <br />        t += f[n // <span style="color:#ff00ff;font-weight:400">2</span>] <br />    f[n] = t <br /><span style="color:#008a8c;font-weight:400">print</span>(f[<span style="color:#ff00ff;font-weight:400">17</span>])</pre></div></p><p>Пример программы с решением через якобы “функцию” (на самом деле список) и запретом прохода через определённое число:</p><p><div class="codebox"><pre><span style="color:#0000ff;font-weight:400"># Команды: +1, *2. </span><br /><span style="color:#0000ff;font-weight:400"># Найти число программ: 2 -&gt; 17, без 7 </span><br />f = [<span style="color:#ff00ff;font-weight:400">0</span>] * <span style="color:#ff00ff;font-weight:400">18</span> <br />f[<span style="color:#ff00ff;font-weight:400">2</span>] = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">3</span>, <span style="color:#ff00ff;font-weight:400">18</span>):  <br />    t = f[n - <span style="color:#ff00ff;font-weight:400">1</span>] <br />    <span style="color:#a52a2a;font-weight:700">if</span> n % <span style="color:#ff00ff;font-weight:400">2</span> == <span style="color:#ff00ff;font-weight:400">0</span>: <br />        t += f[n // <span style="color:#ff00ff;font-weight:400">2</span>] <br />    f[n] = t <br />    <span style="color:#a52a2a;font-weight:700">if</span> n == <span style="color:#ff00ff;font-weight:400">7</span>: <br />        f[n] = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#008a8c;font-weight:400">print</span>(f[<span style="color:#ff00ff;font-weight:400">17</span>])</pre></div></p><p>Пример программы с решением через якобы “функцию” (на самом деле список) и обязательным проходом через определённое число:</p><p><div class="codebox"><pre><span style="color:#0000ff;font-weight:400"># Команды: +1, *2. </span><br /><span style="color:#0000ff;font-weight:400"># Найти число программ: 2 -&gt; 17, через 7 </span><br />f = [<span style="color:#ff00ff;font-weight:400">0</span>] * <span style="color:#ff00ff;font-weight:400">18</span> <br />f[<span style="color:#ff00ff;font-weight:400">2</span>] = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">3</span>, <span style="color:#ff00ff;font-weight:400">18</span>): <br />    t = f[n - <span style="color:#ff00ff;font-weight:400">1</span>] <br />    <span style="color:#a52a2a;font-weight:700">if</span> n % <span style="color:#ff00ff;font-weight:400">2</span> == <span style="color:#ff00ff;font-weight:400">0</span>: <br />        t += f[n // <span style="color:#ff00ff;font-weight:400">2</span>] <br />    f[n] = t <br />    <span style="color:#a52a2a;font-weight:700">if</span> n == <span style="color:#ff00ff;font-weight:400">7</span>: <br />        <span style="color:#a52a2a;font-weight:700">for</span> p <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n): <br />            f[p] = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(f[<span style="color:#ff00ff;font-weight:400">17</span>])</pre></div></p><p>Дополнительный способ для случаев с обязательным проходом через число: разница результата без учёта этого числа и результата с запретом прохода через это число.</p></div><div class='page'><a name="ЕГЭ--24._Обработка_символьных_последовательностей_(не_по_демо-2025)_26.html"></a><h1 class='title level-2'>24. Обработка символьных последовательностей (не по демо-2025)</h1><br/><p><h1>Что нужно знать</h1><ul><li>Как считывать строку из файла, в том числе использование метода strip.</li><li>Основные приёмы, методы, функции работы со строками:<ul><li>посимвольная обработка;</li><li>использование replace, split, in;</li><li>многократные запуски программы или цикл для подбора ответа.</li></ul></li></ul></p><p></p><p><h1>Виды заданий</h1></p><p>Обычно требуется найти самую длинную подстроку, обладающую определённым свойством</p><p></p><p><h2>Подстрока без одинаковых символов подряд</h2></p><p>Пример программы:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />k = m = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#008a8c;font-weight:400">len</span>(s)): <br />    <span style="color:#a52a2a;font-weight:700">if</span> s[i] != s[i - <span style="color:#ff00ff;font-weight:400">1</span>]: <br />        k += <span style="color:#ff00ff;font-weight:400">1</span> <br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, k) <br />    <span style="color:#a52a2a;font-weight:700">else</span>: <br />        k = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p><h2>Подстрока со всеми одинаковыми символами подряд</h2></p><p>Пример программы:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />k = m = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#008a8c;font-weight:400">len</span>(s)): <br />    <span style="color:#a52a2a;font-weight:700">if</span> s[i] == s[i - <span style="color:#ff00ff;font-weight:400">1</span>]: <br />        k += <span style="color:#ff00ff;font-weight:400">1</span> <br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, k) <br />    <span style="color:#a52a2a;font-weight:700">else</span>: <br />        k = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p><h2>Подстрока без определённых символов</h2></p><p>Пример программы:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />k = m = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(s)): <br />    <span style="color:#a52a2a;font-weight:700">if</span> s[i] <span style="color:#a52a2a;font-weight:700">not</span> <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#ff00ff;font-weight:400">&#39;abc&#39;</span>: <br />        k += <span style="color:#ff00ff;font-weight:400">1</span> <br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, k) <br />    <span style="color:#a52a2a;font-weight:700">else</span>: <br />        k = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(m) </pre></div></p><p><h2>Подстрока с определёнными символами подряд</h2></p><p>Пример программы:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />k = m = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(s)): <br />    <span style="color:#a52a2a;font-weight:700">if</span> s[i] <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#ff00ff;font-weight:400">&#39;abc&#39;</span>: <br />        k += <span style="color:#ff00ff;font-weight:400">1</span> <br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, k) <br />    <span style="color:#a52a2a;font-weight:700">else</span>: <br />        k = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(m) </pre></div></p><p><h2>Подстрока, не содержащая определённую подстроку</h2></p><p>Пример программы:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    s = f.readline().strip()<br /><br />t = <span style="color:#ff00ff;font-weight:400">&#39;xyzzy&#39;</span> <br />m = <span style="color:#ff00ff;font-weight:400">0</span> <br />p = <span style="color:#ff00ff;font-weight:400">&#39;&#39;</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(s)): <br />    p += s[i] <br />    <span style="color:#a52a2a;font-weight:700">if</span> t <span style="color:#a52a2a;font-weight:700">not</span> <span style="color:#a52a2a;font-weight:700">in</span> p: <br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, <span style="color:#008a8c;font-weight:400">len</span>(p)) <br />    <span style="color:#a52a2a;font-weight:700">else</span>: <br />        p = t[<span style="color:#ff00ff;font-weight:400">1</span>:] <br /><span style="color:#008a8c;font-weight:400">print</span>(m) </pre></div></p><p><h2>Подстрока с определённым количеством определённых символов</h2></p><p>Пример программы, использующей метод скользящего окна:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />m = <span style="color:#ff00ff;font-weight:400">0</span><br />p = <span style="color:#ff00ff;font-weight:400">&#39;&#39;</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(s)): <br />    p += s[i] <br />    <span style="color:#a52a2a;font-weight:700">while</span> p.count(<span style="color:#ff00ff;font-weight:400">&#39;a&#39;</span>) == <span style="color:#ff00ff;font-weight:400">4</span> + <span style="color:#ff00ff;font-weight:400">1</span>: <br />        p = p[<span style="color:#ff00ff;font-weight:400">1</span>:] <br />    m = <span style="color:#008a8c;font-weight:400">max</span>(m, <span style="color:#008a8c;font-weight:400">len</span>(p)) <br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p>Пример программы, использующей метод двух указателей:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />left = right = <span style="color:#ff00ff;font-weight:400">0</span> <br />k = <span style="color:#ff00ff;font-weight:400">1</span> <span style="color:#a52a2a;font-weight:700">if</span> s[<span style="color:#ff00ff;font-weight:400">0</span>] == <span style="color:#ff00ff;font-weight:400">&#39;a&#39;</span> <span style="color:#a52a2a;font-weight:700">else</span> <span style="color:#ff00ff;font-weight:400">0</span> <br />m = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> right &lt; <span style="color:#008a8c;font-weight:400">len</span>(s) - <span style="color:#ff00ff;font-weight:400">1</span>: <br />    <span style="color:#a52a2a;font-weight:700">if</span> k &lt;= <span style="color:#ff00ff;font-weight:400">4</span>: <br />        right += <span style="color:#ff00ff;font-weight:400">1</span> <br />        <span style="color:#a52a2a;font-weight:700">if</span> s[right] == <span style="color:#ff00ff;font-weight:400">&#39;a&#39;</span>: <br />            k += <span style="color:#ff00ff;font-weight:400">1</span> <br />    <span style="color:#a52a2a;font-weight:700">else</span>: <br />        <span style="color:#a52a2a;font-weight:700">if</span> s[left] == <span style="color:#ff00ff;font-weight:400">&#39;a&#39;</span>: <br />            k -= <span style="color:#ff00ff;font-weight:400">1</span> <br />        left += <span style="color:#ff00ff;font-weight:400">1</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> k == <span style="color:#ff00ff;font-weight:400">4</span>: <br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, right - left + <span style="color:#ff00ff;font-weight:400">1</span>) <br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p>Пример программы, использующей разбиение исходной строки на части:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />m = <span style="color:#ff00ff;font-weight:400">0</span> <br />p = [<span style="color:#008a8c;font-weight:400">len</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> s.split(<span style="color:#ff00ff;font-weight:400">&#39;a&#39;</span>)] <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(p) - <span style="color:#ff00ff;font-weight:400">3</span>): <br />    m = <span style="color:#008a8c;font-weight:400">max</span>(m, <span style="color:#008a8c;font-weight:400">sum</span>(p[i: i + <span style="color:#ff00ff;font-weight:400">5</span>]) + <span style="color:#ff00ff;font-weight:400">4</span>) <br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p><h3>Подстрока, состоящая из периодически повторяющихся символов</h3></p><p><h4>Простой период (ABCABC...)</h4></p><p>Пример программы, рассчитанной на полный период:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />n = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> <span style="color:#ff00ff;font-weight:400">&#39;abc&#39;</span> * n <span style="color:#a52a2a;font-weight:700">in</span> s: <br />    n += <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(n - <span style="color:#ff00ff;font-weight:400">1</span>)</pre></div></p><p>Пример краткой программы, рассчитанной на полный период и многократные запуски с подбором ответа:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br /><span style="color:#0000ff;font-weight:400"># Подбираем множитель </span><br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#ff00ff;font-weight:400">&#39;abc&#39;</span> * <span style="color:#ff00ff;font-weight:400">3</span> <span style="color:#a52a2a;font-weight:700">in</span> s) </pre></div></p><p>Пример программы, рассчитанной на полный период:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />p = <span style="color:#ff00ff;font-weight:400">&#39;abc&#39;</span> * <span style="color:#008a8c;font-weight:400">len</span>(s) <br />n = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> p[:n] <span style="color:#a52a2a;font-weight:700">in</span> s: <br />    n += <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(n - <span style="color:#ff00ff;font-weight:400">1</span>)</pre></div></p><p>Пример краткой программы, рассчитанной на полный период и многократные запуски с подбором ответа:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br /><span style="color:#0000ff;font-weight:400"># Подбираем множитель и дополнение </span><br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#ff00ff;font-weight:400">&#39;abc&#39;</span> * <span style="color:#ff00ff;font-weight:400">3</span> + <span style="color:#ff00ff;font-weight:400">&#39;a&#39;</span> <span style="color:#a52a2a;font-weight:700">in</span> s) </pre></div></p><p><h4>Перекрывающийся период (ABCCBAABC...)</h4></p><p>Пример программы, рассчитанной на полный период:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;abcba&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;abc cba&#39;</span>) <br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;cbabc&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;cba abc&#39;</span>) <br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;cba&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;abc&#39;</span>) <br /><br />n = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> <span style="color:#ff00ff;font-weight:400">&#39;abc&#39;</span> * n <span style="color:#a52a2a;font-weight:700">in</span> s: <br />    n += <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(n - <span style="color:#ff00ff;font-weight:400">1</span>)</pre></div></p><p>Пример краткой программы, рассчитанной на полный период и многократные запуски с подбором ответа:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;abcba&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;abc cba&#39;</span>) <br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;cbabc&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;cba abc&#39;</span>) <br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;cba&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;abc&#39;</span>)<br /><br /><span style="color:#0000ff;font-weight:400"># Подбираем множитель </span><br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#ff00ff;font-weight:400">&#39;abc&#39;</span> * <span style="color:#ff00ff;font-weight:400">3</span> <span style="color:#a52a2a;font-weight:700">in</span> s) </pre></div></p><p><h4>Сложный период</h4></p><p>Пример программы, рассчитанной на полный период:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;c&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;b&#39;</span>) <br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;d&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;b&#39;</span>)<br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;e&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;a&#39;</span>) <br /><br />n = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> <span style="color:#ff00ff;font-weight:400">&#39;bab&#39;</span> * n <span style="color:#a52a2a;font-weight:700">in</span> s: <br />    n += <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(n - <span style="color:#ff00ff;font-weight:400">1</span>)</pre></div></p><p>Пример краткой программы, рассчитанной на полный период и многократные запуски с подбором ответа:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    s = f.readline().strip() <br /><br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;c&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;b&#39;</span>) <br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;d&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;b&#39;</span>)<br />s = s.replace(<span style="color:#ff00ff;font-weight:400">&#39;e&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;a&#39;</span>) <br /><br /><br /><span style="color:#0000ff;font-weight:400"># Подбираем множитель </span><br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#ff00ff;font-weight:400">&#39;bab&#39;</span> * <span style="color:#ff00ff;font-weight:400">3</span> <span style="color:#a52a2a;font-weight:700">in</span> s) </pre></div></p></div><div class='page'><a name="ЕГЭ--25._Перебор_чисел_27.html"></a><h1 class='title level-2'>25. Перебор чисел</h1><br/><p><h1>Числа по маске</h1></p><p></p><p><h2>Заданы подстановочные знаки только “?”</h2></p><p>Пример программы, перебирающей группы всех возможных цифр:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">for</span> a <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">10</span>): <br />    <span style="color:#a52a2a;font-weight:700">for</span> b <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">10</span>): <br />        <span style="color:#a52a2a;font-weight:700">for</span> c <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">10</span>): <br />            n = <span style="color:#008a8c;font-weight:400">int</span>(f<span style="color:#ff00ff;font-weight:400">&#39;12{a}3{b}{c}456&#39;</span>) <br />            <span style="color:#a52a2a;font-weight:700">if</span> n % ДЕЛИТЕЛЬ == <span style="color:#ff00ff;font-weight:400">0</span>: <br />                <span style="color:#008a8c;font-weight:400">print</span>(n, n // ДЕЛИТЕЛЬ)</pre></div></p><p></p><p><h2>Заданы подстановочные знаки “*”</h2></p><p>Перебирать цифры, которым соответствует каждый символ “*”, сложно, поэтому пишем программу на перебор чисел с сопоставлением их маске.</p><p></p><p><h3>Программа с модулем fnmatch</h3></p><p>Общий вид программы:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">import</span> fnmatch <br /><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(ДЕЛИТЕЛЬ, ПРЕДЕЛ, ДЕЛИТЕЛЬ): <br />    <span style="color:#a52a2a;font-weight:700">if</span> fnmatch.fnmatch(<span style="color:#008a8c;font-weight:400">str</span>(n), <span style="color:#ff00ff;font-weight:400">&#39;МАСКА&#39;</span>): <br />        <span style="color:#008a8c;font-weight:400">print</span>(n, n // ДЕЛИТЕЛЬ)</pre></div></p><p>Пример программы:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">import</span> fnmatch <br /><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">189</span>, <span style="color:#ff00ff;font-weight:400">10</span>**<span style="color:#ff00ff;font-weight:400">9</span>, <span style="color:#ff00ff;font-weight:400">189</span>): <br />    <span style="color:#a52a2a;font-weight:700">if</span> fnmatch.fnmatch(<span style="color:#008a8c;font-weight:400">str</span>(n), <span style="color:#ff00ff;font-weight:400">&#39;24*7*45?8&#39;</span>): <br />        <span style="color:#008a8c;font-weight:400">print</span>(n, n // <span style="color:#ff00ff;font-weight:400">189</span>)</pre></div></p><p><h3>Программа с модулем re (немного быстрее, но сложнее)</h3></p><p>Общий вид программы:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">import</span> re <br />expr = re.compile(<span style="color:#ff00ff;font-weight:400">&#39;РЕГУЛЯРНОЕ ВЫРАЖЕНИЕ&#39;</span>) <br /><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(ДЕЛИТЕЛЬ, ПРЕДЕЛ, ДЕЛИТЕЛЬ): <br />    <span style="color:#a52a2a;font-weight:700">if</span> expr.search(<span style="color:#008a8c;font-weight:400">str</span>(n)): <br />        <span style="color:#008a8c;font-weight:400">print</span>(n, n // ДЕЛИТЕЛЬ)</pre></div></p><p>Пример программы:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">import</span> re <br />expr = re.compile(<span style="color:#ff00ff;font-weight:400">&#39;^24.*7.*45.8&#39;</span>) <br /><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">189</span>, 1_000_000_000, <span style="color:#ff00ff;font-weight:400">189</span>): <br />    <span style="color:#a52a2a;font-weight:700">if</span> expr.search(<span style="color:#008a8c;font-weight:400">str</span>(n)): <br />        <span style="color:#008a8c;font-weight:400">print</span>(n, n // <span style="color:#ff00ff;font-weight:400">189</span>)</pre></div></p><p>Актуальные правила синтаксиса re:<ul><li>вместо “?” пишем “.”;</li><li>вместо “*” пишем “.*”;</li><li>ставим “^” в начале регулярного выражения;</li><li>ставим “$” в конце регулярного выражения.</li></ul></p><p></p><p><h1>Числа по свойствам их делителей</h1><h1></h1></p><p><h1></h1>Требуется определить числа на определённом интервале, удовлетворяющие некоторому условию на их делители.</p><p>С учётом величины используемых в заданиях чисел можно использовать списковое включение.</p><p>Пример получения списка делителей числа за исключением единицы и самого числа:</p><p><div class="codebox"><pre>a = [d <span style="color:#a52a2a;font-weight:700">for</span> d <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">2</span>, n) <span style="color:#a52a2a;font-weight:700">if</span> n % d == <span style="color:#ff00ff;font-weight:400">0</span>]</pre></div></p><p>Далее можно проверять условия на количество делителей, на минимальный и максимальный делитель (в этом списке они идут по возрастанию) и прочие соотношения.</p><p>Пример получения чисел, принадлежащих промежутку [150000; 150040], имеющих ровно два различных натуральных делителя помимо единицы и самого числа, с выводом каждого такого числа и суммы тех двух его делителей:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">for</span> n <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(150_000, 150_040 + <span style="color:#ff00ff;font-weight:400">1</span>):<br />    a = [d <span style="color:#a52a2a;font-weight:700">for</span> d <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">2</span>, n) <span style="color:#a52a2a;font-weight:700">if</span> n % d == <span style="color:#ff00ff;font-weight:400">0</span>]<br />    <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">len</span>(a) == <span style="color:#ff00ff;font-weight:400">2</span>:<br />        <span style="color:#008a8c;font-weight:400">print</span>(n, a[<span style="color:#ff00ff;font-weight:400">0</span>] + a[-<span style="color:#ff00ff;font-weight:400">1</span>])</pre></div></p></div><div class='page'><a name="ЕГЭ--26._Обработка_чисел_с_использованием_сортировки_(не_по_демо-2025)_28.html"></a><h1 class='title level-2'>26. Обработка чисел с использованием сортировки (не по демо-2025)</h1><br/><p><h1>Что нужно уметь</h1><ul><li>Читать и понимать сюжет задания, пользоваться примером для уточнения понимания.</li><li>Открывать текстовый файл в табличном процессоре (и Excel, и Calc) так, чтобы каждое число попало в отдельную ячейку.</li><li>Выполнять сортировку, правильно определяя направления и ключи сортировки и правильно учитывая направление в дальнейшем.</li></ul></p><p></p><p>По возможности предпочитаем решение в табличном процессоре, т. к. оно нагляднее, чем решение написанием программы.</p><p></p><p><h1>Эффекты сортировки</h1><ul><li>Известно, где находится много минимальных/максимальных значений.</li><li>Одинаковые и близкие значения оказываются рядом друг с другом.</li><li>Можно применять жадные алгоритмы.</li><li>Легко осуществлять поиск значений (двоичный поиск).</li></ul></p><p></p><p><h1>Основные приёмы решения</h1><ol><li>Накопляемая сумма. Применяется, если нужно уместить максимальное или минимальное количество элементов в некоторое ограничение по их сумме. Типовые сюжеты: “Системный администратор и файлы”, “Онлайн-конференция и ролики”.</li><li>Сохранение последнего использованного значения. Применяется, если нужно выбрать максимальное количество элементов, которые не мешают друг другу (не перекрываются, имеют разницу не менее заданной и т. п.). Типовые сюжеты: “Один подарок в множестве коробок”, “Конференция и мероприятия”.</li><li>Порядковый расчёт со сбросом. Применяется, если нужно выбрать максимальное количество групп элементов (по 2, по 3 и т. п.), близких друг к другу, или некоторые такие группы. Типовые сюжеты: “Подарки, каждый подарок в нескольких коробках”, “Фрагменты труб”.</li><li>Определение серий объектов, расположенных в линию, если даны двумерные координаты объектов. Типовые сюжеты: “Зрительный зал”, “Точки на экране”.</li><li>Использование квартилей и т. п. статистических показателей, а также пропуск известных элементов в отсортированном списке. Применяется, если необходимо учесть некоторое известное количество наибольших/наименьших элементов, а также если есть условие строго на каждый N-й элемент. Типовой сюжет: “Касса в магазине”.</li><li>Моделирование. Используется, если при прохождении отсортированного списка нужно хранить и изменять большое количество текущих данных. Решение программное. Типовой сюжет: “Камера хранения”.</li><li>Несинхронный проход нескольких отсортированных списков. Используется, если нужно установить взаимное соответствие элементов списков. Решение программное. Типовой сюжет: “Коробки и подарки, каждый подарок в отдельной коробке”.</li></ol></p><p></p><p><h1>Сюжеты</h1></p><p></p><p><h2>Предельное количество элементов в сумме, с величиной максимального элемента (&quot;Системный администратор и файлы&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, запоминаем и убираем предельную сумму игнорируем число файлов.</li><li>Сортируем файлы пользователей по возрастанию размера.</li><li>Создаём столбец с накопленной суммой.  Формула: =B1+A2</li><li>Ищем макс. сумму, не превышающую предел.</li><li>Порядковый номер последнего слагаемого - 1-е число в ответе.</li><li>Определяем запас по размеру файла и макс. значение элемента с его учётом.</li><li>Ищем макс. элемент, не превышающий это значение - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    <span style="color:#0000ff;font-weight:400"># Считываем первую строку (предел суммы и кол-во файлов) </span><br />    m, n = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split()) <br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br /><span style="color:#0000ff;font-weight:400"># Сортируем файлы по неубыванию </span><br />a.sort() <br /><span style="color:#0000ff;font-weight:400"># Выбираем файлы по порядку, накапливая сумму </span><br />k = <span style="color:#ff00ff;font-weight:400">0</span> <br />s = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> s &lt;= m: <br />    s += a[k] <br />    k += <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#0000ff;font-weight:400"># Отходим на один файл назад, т. к. превысили предел суммы </span><br />k -= <span style="color:#ff00ff;font-weight:400">1</span> <br />s -= a[k] <br /><span style="color:#0000ff;font-weight:400"># Определям запас места на диске и макс. размер реального файла </span><br />d = m - (s - a[k]) <br />t = <span style="color:#008a8c;font-weight:400">max</span>([x <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a <span style="color:#a52a2a;font-weight:700">if</span> x &lt;= d]) <br /><span style="color:#008a8c;font-weight:400">print</span>(k, t)</pre></div></p><p></p><p><h2>Предельное количество элементов в сумме, с количеством неподходящих элементов (&quot;Видеоконференция и ролики&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, запоминаем и убираем предельную сумму, игнорируем число роликов.</li><li>Сортируем файлы пользователей по возрастанию размера.</li><li>Создаём столбец с накопленной суммой.  Формула: =B1+A2</li><li>Ищем макс. сумму, не превышающую предел.</li><li>Порядковый номер последнего слагаемого - 1-е число в ответе.</li><li>Определяем запас по размеру файла и макс. значение элемента с его учётом.</li><li>Ищем количество элементов, превышающих это значение, - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    <span style="color:#0000ff;font-weight:400"># Считываем первую строку (предел суммы и кол-во файлов) </span><br />    m, n = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split()) <br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br /><span style="color:#0000ff;font-weight:400"># Сортируем файлы по неубыванию </span><br />a.sort() <br /><span style="color:#0000ff;font-weight:400"># Выбираем файлы по порядку, накапливая сумму </span><br />k = <span style="color:#ff00ff;font-weight:400">0</span> <br />s = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> s &lt;= m: <br />    s += a[k] <br />    k += <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#0000ff;font-weight:400"># Отходим на один файл назад, т. к. превысили предел суммы </span><br />k -= <span style="color:#ff00ff;font-weight:400">1</span> <br />s -= a[k] <br /><span style="color:#0000ff;font-weight:400"># Определям запас места на диске и количество неподходящих файлов </span><br />d = m - (s - a[k]) <br />t = <span style="color:#008a8c;font-weight:400">len</span>([x <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a <span style="color:#a52a2a;font-weight:700">if</span> x &gt; d]) <br /><span style="color:#008a8c;font-weight:400">print</span>(k, t)</pre></div></p><p></p><p><h2>Максимальное подмножество с большой разницей элементов (&quot;Подарок и много коробок&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, игнорируем число коробок.</li><li>Сортируем размеры коробок в зависимости от второго вопроса задания (для получения макс. значения начинаем с макс. значений, т. е. по убыванию).</li><li>Первую коробку всегда берём.</li><li>Создаём столбец с размером последней взятой коробки согласно разнице в размерах.  Формула: =ЕСЛИ(A2-B1&gt;=РАЗНИЦА; A2; B1)</li><li>Создаём столбец с логическим значением (взяли коробку или нет) согласно изменению размера взятой коробки.  Формула =B2&lt;&gt;B1</li><li>Определяем число &quot;истин&quot; (СЧЁТЕСЛИ) - 1-е число в ответе.</li><li>Размер коробки с последней &quot;истиной&quot; - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    f.readline() <br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br /><span style="color:#0000ff;font-weight:400"># Сортируем файлы согласно выбранному порядку </span><br />a.sort() <br /><span style="color:#0000ff;font-weight:400"># Перебираем коробки </span><br />k = <span style="color:#ff00ff;font-weight:400">1</span> <br />p = a[<span style="color:#ff00ff;font-weight:400">0</span>] <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#008a8c;font-weight:400">len</span>(a)): <br />    <span style="color:#0000ff;font-weight:400"># Сравниваем размеры коробок согласно выбранному порядку </span><br />    <span style="color:#a52a2a;font-weight:700">if</span> a[i] - p &gt;= РАЗНИЦА: <br />        k += <span style="color:#ff00ff;font-weight:400">1</span> <br />        p = a[i] <br /><span style="color:#008a8c;font-weight:400">print</span>(k, p)</pre></div></p><p></p><p><h2>Максимальное число групп элементов с небольшой разницей (&quot;Подарки, каждый в нескольких коробках&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, игнорируем число коробок.</li><li>Сортируем размеры коробок в зависимости от второго вопроса задания (для получения макс. значения начинаем с макс. значений, т. е. по убыванию).</li><li>У первой коробки всегда номер 1 в группе.</li><li>Создаём столбец с порядковым номером коробки в группе.  Формула:  =ЕСЛИ(И(A2-A1&lt;=РАЗНИЦА; A1&lt;РАЗМЕР_ГРУППЫ; B1+1; 1)</li><li>Количество значений номеров коробок, равных размеру группы, - 1-е число в ответе.  Формула: =СЧЁТЕСЛИ(B:B; РАЗМЕР_ГРУППЫ)</li><li>Размер коробки с последним значением размера группы - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    f.readline() <br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br /><span style="color:#0000ff;font-weight:400"># Сортируем файлы согласно выбранному порядку </span><br />a.sort() <br /><span style="color:#0000ff;font-weight:400"># Перебираем коробки </span><br />k = <span style="color:#ff00ff;font-weight:400">0</span> <br />t = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#008a8c;font-weight:400">len</span>(a)): <br />    <span style="color:#0000ff;font-weight:400"># Сравниваем размеры коробок согласно выбранному порядку </span><br />    <span style="color:#a52a2a;font-weight:700">if</span> a[i] - a[i - <span style="color:#ff00ff;font-weight:400">1</span>] &lt;= РАЗНИЦА <span style="color:#a52a2a;font-weight:700">and</span> t &lt; РАЗМЕР_ГРУППЫ: <br />        t += <span style="color:#ff00ff;font-weight:400">1</span> <br />        <span style="color:#a52a2a;font-weight:700">if</span> t == РАЗМЕР_ГРУППЫ: <br />            k += <span style="color:#ff00ff;font-weight:400">1</span> <br />            p = a[i] <br />    <span style="color:#a52a2a;font-weight:700">else</span>: <br />        t = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(k, p)</pre></div></p><p></p><p><h2>Условие на процентили и прочие статистики (&quot;Касса, каждый N-й товар за полцены&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, убираем число товаров.</li><li>Сортируем товары по убыванию цен.</li><li>Определяем 1/N часть общего количества.</li><li>Считаем сумму: первая 1/N часть за полцены, остальные - за полную - 1-е число в ответе.</li><li>Сортируем товары по убыванию цен, далее аналогично - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    f.readline() <br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br />p = <span style="color:#008a8c;font-weight:400">len</span>(a) // N <br />a.sort(reverse=<span style="color:#ff00ff;font-weight:400">True</span>) <br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#008a8c;font-weight:400">sum</span>(a[:p]) // <span style="color:#ff00ff;font-weight:400">2</span> + <span style="color:#008a8c;font-weight:400">sum</span>(a[p:]))<br />a = a[::-<span style="color:#ff00ff;font-weight:400">1</span>] <br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#008a8c;font-weight:400">sum</span>(a[:p]) // <span style="color:#ff00ff;font-weight:400">2</span> + <span style="color:#008a8c;font-weight:400">sum</span>(a[p:]))</pre></div></p><p></p><p><h2>Условие на процентили и на каждый N-й элемент в упорядоченном наборе (&quot;Касса, каждый N-й товар в чеке бесплатно&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, убираем число товаров.</li><li>Сортируем товары по убыванию цен.</li><li>Определяем 1/N часть общего количества.</li><li>Считаем сумму: первая 1/N часть за полцены, остальные - за полную - 1-е число в ответе.</li><li>Создаём столбец с ценами для оплаты: N-1 число - так же, N-е - пустое, протягиваем все N ячеек вниз.</li><li>Сумма созданного столбца - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    f.readline() <br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br />p = <span style="color:#008a8c;font-weight:400">len</span>(a) // N <br />a.sort(reverse=<span style="color:#ff00ff;font-weight:400">True</span>) <br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#008a8c;font-weight:400">sum</span>(a[p:])) <br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#008a8c;font-weight:400">sum</span>(a) - <span style="color:#008a8c;font-weight:400">sum</span>(a[N-<span style="color:#ff00ff;font-weight:400">1</span>::N]))</pre></div></p><p></p><p><h2>Самая большая группа элементов с небольшой разницей (&quot;Трубы из фрагментов&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, игнорируем число фрагментов, запоминаем и убираем размер трубы.</li><li>Сортируем фрагменты по убыванию диаметра.</li><li>У первого фрагмента всегда номер 1 в группе.</li><li>Создаём столбец с порядковым номером фрагмента в группе.  Формула:  =ЕСЛИ(И(A2-A1&lt;=РАЗНИЦА; A1&lt;РАЗМЕР_ГРУППЫ; B1+1; 1)</li><li>Размер минимального фрагмента в первой (самой большой) группе - 1-е число в ответе.</li><li>Смещаем группу до упора вниз так, чтобы минимальное число не стало меньше.</li><li>Максимальное число в смещённой группе - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    n, m = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split()) <br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br />a.sort(reverse=<span style="color:#ff00ff;font-weight:400">True</span>) <br /><span style="color:#0000ff;font-weight:400"># Набираем подходящую группу из m самых больших фрагментов </span><br />k = <span style="color:#ff00ff;font-weight:400">1</span> <br />i = <span style="color:#ff00ff;font-weight:400">1</span> <br />r = <span style="color:#ff00ff;font-weight:400">None</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> k &lt; m: <br />    <span style="color:#a52a2a;font-weight:700">if</span> a[i - <span style="color:#ff00ff;font-weight:400">1</span>] - a[i] &lt;= РАЗНИЦА: <br />        k += <span style="color:#ff00ff;font-weight:400">1</span> <br />    <span style="color:#a52a2a;font-weight:700">else</span>: <br />        k = <span style="color:#ff00ff;font-weight:400">1</span> <br />    <span style="color:#a52a2a;font-weight:700">if</span> k == m: <br />        <span style="color:#a52a2a;font-weight:700">break</span> <br />    i += <span style="color:#ff00ff;font-weight:400">1</span> <br />r = a[i] <br /><span style="color:#0000ff;font-weight:400"># Смещаем группу фрагментов на уменьшение, пока не уменьшается минимальный фрагмент </span><br /><span style="color:#a52a2a;font-weight:700">while</span> a[i] == a[i + <span style="color:#ff00ff;font-weight:400">1</span>]: <br />    i += <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(r, a[i - k + <span style="color:#ff00ff;font-weight:400">1</span>])</pre></div></p><p></p><p><h2>Серии отсутствующих элементов, найти определённую серию (&quot;Места в зрительном зале&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, игнорируем число мест.</li><li>Сортируем места по составному ключу: по убыванию номера ряда, затем по возрастанию номера места в ряду.</li><li>Создаём столбец с признаком, есть ли после заданного места подходящая серия.  Формула:  =И(A2=A1; A2-A1=РАЗМЕР_СЕРИИ+1)</li><li>Номер ряда (первое число в паре) с первой &quot;истиной&quot; - 1-е число в ответе.</li><li>Номер занятого места (второе число в паре) плюс единица - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    f.readline() <br />    a = [<span style="color:#008a8c;font-weight:400">tuple</span>(<span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, x.split())) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br /><span style="color:#0000ff;font-weight:400"># Сортируем по убыванию номера ряда, затем - по возрастанию номера места в ряду </span><br />a.sort(key=<span style="color:#a52a2a;font-weight:700">lambda</span> x: (-x[<span style="color:#ff00ff;font-weight:400">0</span>], x[<span style="color:#ff00ff;font-weight:400">1</span>])) <br /><span style="color:#0000ff;font-weight:400"># Ищем занятое место рядом с первой подхоядящей серией </span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(a) - <span style="color:#ff00ff;font-weight:400">1</span>): <br />    <span style="color:#a52a2a;font-weight:700">if</span> a[i][<span style="color:#ff00ff;font-weight:400">0</span>] == a[i + <span style="color:#ff00ff;font-weight:400">1</span>][<span style="color:#ff00ff;font-weight:400">0</span>] <span style="color:#a52a2a;font-weight:700">and</span> a[i + <span style="color:#ff00ff;font-weight:400">1</span>][<span style="color:#ff00ff;font-weight:400">1</span>] - a[i][<span style="color:#ff00ff;font-weight:400">1</span>] - <span style="color:#ff00ff;font-weight:400">1</span> == РАЗМЕР_СЕРИИ: <br />        <span style="color:#008a8c;font-weight:400">print</span>(a[i][<span style="color:#ff00ff;font-weight:400">0</span>], a[i][<span style="color:#ff00ff;font-weight:400">1</span>] + <span style="color:#ff00ff;font-weight:400">1</span>) <br />        <span style="color:#a52a2a;font-weight:700">break</span></pre></div></p><p></p><p><h2>Серии отсутствующих элементов, найти максимальную серию (&quot;Места в зрительном зале&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, игнорируем число мест.</li><li>Сортируем места по составному ключу: по убыванию номера ряда, затем по возрастанию номера места в ряду.</li><li>Создаём столбец с количеством свободных мест между этим занятым и следующим; при разных рядах результат 0.  Формула:  =ЕСЛИ(A2=A1; A2-A1-1; 0)</li><li>Максимум по созданному столбцу - 2-е число в ответе.</li><li>Строка, в которой находится максимум (самая первая, находим поиском по значениям ячеек), - 1-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    f.readline() <br />    a = [<span style="color:#008a8c;font-weight:400">tuple</span>(<span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, x.split())) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br />a.sort(key=<span style="color:#a52a2a;font-weight:700">lambda</span> x: (-x[<span style="color:#ff00ff;font-weight:400">0</span>], x[<span style="color:#ff00ff;font-weight:400">1</span>])) <br />m = <span style="color:#ff00ff;font-weight:400">0</span> <br />r = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(a) - <span style="color:#ff00ff;font-weight:400">1</span>): <br />    <span style="color:#a52a2a;font-weight:700">if</span> a[i][<span style="color:#ff00ff;font-weight:400">0</span>] == a[i + <span style="color:#ff00ff;font-weight:400">1</span>][<span style="color:#ff00ff;font-weight:400">0</span>]: <br />        d = a[i + <span style="color:#ff00ff;font-weight:400">1</span>][<span style="color:#ff00ff;font-weight:400">1</span>] - a[i][<span style="color:#ff00ff;font-weight:400">1</span>] - <span style="color:#ff00ff;font-weight:400">1</span> <br />        <span style="color:#a52a2a;font-weight:700">if</span> d &gt; m: <br />            m = d <br />            r = a[i][<span style="color:#ff00ff;font-weight:400">0</span>] <br /><span style="color:#008a8c;font-weight:400">print</span>(r, m)</pre></div></p><p></p><p><h2>Серии имеющихся элементов (&quot;Точки на экране&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, игнорируем число точек.</li><li>Сортируем координаты точек по возрастанию номера ряда, затем по возрастанию места в ряду.</li><li>Создаём столбец с порядковым номером точки в серии.  Формула для C2:  =ЕСЛИ(A2=A1; ЕСЛИ(A2-A1=1; C1+1; ЕСЛИ(A2=A1; C1; 1)); 1)<ul><li>номер самой первой точки - 1;</li><li>если началась новая строка, то 1;</li><li>если строка та же и разница мест равна 1, то +1 к предыдущему номеру;</li><li>если строка та же и место то же, то повторить предыдущий номер.</li></ul></li><li>Создаём ещё один столбец, в котором пишем число из предыдущего, если оно не меньше размера серии и следующее за ним число - единица, в противном случае - 0 или &quot;&quot;.  Формула для D1:  =ЕСЛИ(И(C1&gt;=РАЗМЕР_СЕРИИ; C2=1); C1; &quot;&quot;)</li><li>Отдельно рассматриваем последнее число в последнем столбце: оно может завершать серию, но после него нет единицы; ставим ему соответствующее значение.</li><li>Количество чисел в последнем столбце - 1-е число в ответе.</li><li>Сумма чисел в последнем столбце - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    f.readline() <br />    a = [<span style="color:#008a8c;font-weight:400">tuple</span>(<span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, x.split())) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br />a.sort() <br />k = <span style="color:#ff00ff;font-weight:400">0</span> <br />s = <span style="color:#ff00ff;font-weight:400">0</span> <br />p = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#008a8c;font-weight:400">len</span>(a)): <br />    <span style="color:#a52a2a;font-weight:700">if</span> a[i - <span style="color:#ff00ff;font-weight:400">1</span>][<span style="color:#ff00ff;font-weight:400">0</span>] == a[i][<span style="color:#ff00ff;font-weight:400">0</span>] <span style="color:#a52a2a;font-weight:700">and</span> a[i][<span style="color:#ff00ff;font-weight:400">1</span>] - a[i - <span style="color:#ff00ff;font-weight:400">1</span>][<span style="color:#ff00ff;font-weight:400">1</span>] &lt;= <span style="color:#ff00ff;font-weight:400">1</span>: <br />        <span style="color:#a52a2a;font-weight:700">if</span> a[i][<span style="color:#ff00ff;font-weight:400">1</span>] - a[i - <span style="color:#ff00ff;font-weight:400">1</span>][<span style="color:#ff00ff;font-weight:400">1</span>] == <span style="color:#ff00ff;font-weight:400">1</span>: <br />            p += <span style="color:#ff00ff;font-weight:400">1</span> <br />    <span style="color:#a52a2a;font-weight:700">else</span>: <br />        <span style="color:#a52a2a;font-weight:700">if</span> p &gt;= МИН_РАЗМЕР_СЕРИИ: <br />            k += <span style="color:#ff00ff;font-weight:400">1</span> <br />            s += p <br />        p = <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#a52a2a;font-weight:700">if</span> p &gt;= МИН_РАЗМЕР_СЕРИИ: <br />    k += <span style="color:#ff00ff;font-weight:400">1</span> <br />    s += p <br /><span style="color:#008a8c;font-weight:400">print</span>(k, s)</pre></div></p><p></p><p><h2>Непересекающиеся интервалы, самое раннее время завершения последнего (&quot;Конференция и мероприятия&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, игнорируем число мероприятий.</li><li>Сотрируем мероприятия по возрастанию времени завершения.</li><li>Первое мероприятие всегда посещаем.</li><li>Создаём столбец с временем окончания последнего посещённого мероприятия.  Формула для C1: =B1  Формула для C2: =ЕСЛИ(A2&gt;=C1; B2; C1)</li><li>Создаём столбец с логическим значением (посетили мероприятие или нет) согласно изменению времени последнего посещённого мероприятия.  Значение для D1: ИСТИНА  Формула для D2 и для протягивания: =C2&lt;&gt;C1</li><li>Определяем число &quot;истин&quot; (СЧЁТЕСЛИ) - 1-е число в ответе.</li><li>Время завершения мероприятия с последней &quot;истиной&quot; - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    f.readline() <br />    a = [<span style="color:#008a8c;font-weight:400">tuple</span>(<span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, x.split())) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br />a.sort(key=<span style="color:#a52a2a;font-weight:700">lambda</span> x: x[<span style="color:#ff00ff;font-weight:400">1</span>]) <br />k = <span style="color:#ff00ff;font-weight:400">1</span> <br />last = a[<span style="color:#ff00ff;font-weight:400">0</span>][<span style="color:#ff00ff;font-weight:400">1</span>] <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#008a8c;font-weight:400">len</span>(a)): <br />    <span style="color:#a52a2a;font-weight:700">if</span> a[i][<span style="color:#ff00ff;font-weight:400">0</span>] &gt;= last: <br />        last = a[i][<span style="color:#ff00ff;font-weight:400">1</span>] <br />        k += <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(k, last)</pre></div></p><p></p><p><h2>Непересекающиеся интервалы, позднее раннее время завершения последнего (&quot;Конференция и мероприятия&quot;)</h2></p><p>Алгоритм решения в табличном процессоре:<ol><li>Открываем файл, игнорируем число мероприятий.</li><li>Сотрируем мероприятия по возрастанию времени завершения.</li><li>Первое мероприятие всегда посещаем.</li><li>Создаём столбец с временем окончания последнего посещённого мероприятия.  Формула для C1: =B1  Формула для C2: =ЕСЛИ(A2&gt;=C1; B2; C1)</li><li>Создаём столбец с логическим значением (посетили мероприятие или нет) согласно изменению времени последнего посещённого мероприятия.  Значение для D1: ИСТИНА  Формула для D2 и для протягивания: =C2&lt;&gt;C1</li><li>Определяем число &quot;истин&quot; (СЧЁТЕСЛИ) - 1-е число в ответе.</li><li>Ищем предпоследнюю &quot;истину&quot;, узнаём время завершения этого мероприятия.</li><li>Ищем первую с конца строку, в которой время начала не меньше найденного времени, - 2-е число в ответе.</li></ol></p><p>Пример программы, решающей задачу:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:   <br />    f.readline() <br />    a = [<span style="color:#008a8c;font-weight:400">tuple</span>(<span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, x.split())) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br />a.sort(key=<span style="color:#a52a2a;font-weight:700">lambda</span> x: x[<span style="color:#ff00ff;font-weight:400">1</span>]) <br />k = <span style="color:#ff00ff;font-weight:400">1</span> <br />prev = <span style="color:#ff00ff;font-weight:400">0</span> <br />last = a[<span style="color:#ff00ff;font-weight:400">0</span>][<span style="color:#ff00ff;font-weight:400">1</span>] <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, <span style="color:#008a8c;font-weight:400">len</span>(a)): <br />    <span style="color:#a52a2a;font-weight:700">if</span> a[i][<span style="color:#ff00ff;font-weight:400">0</span>] &gt;= last: <br />        prev = last <br />        last = a[i][<span style="color:#ff00ff;font-weight:400">1</span>] <br />        k += <span style="color:#ff00ff;font-weight:400">1</span> <br />i = <span style="color:#008a8c;font-weight:400">len</span>(a) - <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> a[i][<span style="color:#ff00ff;font-weight:400">0</span>] &lt; prev: <br />    i -= <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(k, a[i][<span style="color:#ff00ff;font-weight:400">1</span>])</pre></div></p><p></p><p><h2>Моделирование (&quot;Камера хранения&quot;)</h2></p><p>Пример программы, решающей задачу моделированием:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    k = <span style="color:#008a8c;font-weight:400">int</span>(f.readline()) <br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline()) <br />    a = [<span style="color:#008a8c;font-weight:400">tuple</span>(<span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, x.split())) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br /><span style="color:#0000ff;font-weight:400"># Сортируем данные о пассажирах по времени прихода </span><br />a.sort() <br /><span style="color:#0000ff;font-weight:400"># Определяем начальное состояние ячеек </span><br />storage = [<span style="color:#ff00ff;font-weight:400">0</span>] * k <br />p = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#0000ff;font-weight:400"># Моделируем работу камеры хранения </span><br /><span style="color:#a52a2a;font-weight:700">for</span> t <span style="color:#a52a2a;font-weight:700">in</span> a: <br />    <span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(k): <br />        <span style="color:#a52a2a;font-weight:700">if</span> storage[i] &lt; t[<span style="color:#ff00ff;font-weight:400">0</span>]: <br />            <span style="color:#0000ff;font-weight:400"># Пассажир помещает багаж в уже свободную ячейку </span><br />            storage[i] = t[<span style="color:#ff00ff;font-weight:400">1</span>] <br />            p += <span style="color:#ff00ff;font-weight:400">1</span> <br />            last = i + <span style="color:#ff00ff;font-weight:400">1</span> <br />            <span style="color:#a52a2a;font-weight:700">break</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(p, last)</pre></div></p><p></p><p><h2>Сравнение двух списков (&quot;Коробки и предметы&quot;)</h2></p><p>Пример программы, решающей задачу перебором соответствий и обнулением размеров коробок (не очень эффективно):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    n, m = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split()) <br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br />items = a[:n] <br />boxes = a[n:] <br />items.sort(reverse=<span style="color:#ff00ff;font-weight:400">True</span>) <br />boxes.sort(reverse=<span style="color:#ff00ff;font-weight:400">True</span>) <br />k = <span style="color:#ff00ff;font-weight:400">0</span> <br />last = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(items)): <br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(boxes)): <br />        <span style="color:#a52a2a;font-weight:700">if</span> items[i] &lt;= boxes[j]: <br />            k += <span style="color:#ff00ff;font-weight:400">1</span> <br />            last = items[i] <br />            boxes[j] = <span style="color:#ff00ff;font-weight:400">0</span> <br />            <span style="color:#a52a2a;font-weight:700">break</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(k, last)</pre></div></p><p>Пример программы, решающей задачу одним проходом по предметам:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    n, m = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split()) <br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br />items = a[:n] <br />boxes = a[n:] <br />items.sort(reverse=<span style="color:#ff00ff;font-weight:400">True</span>) <br />boxes.sort(reverse=<span style="color:#ff00ff;font-weight:400">True</span>) <br />k = <span style="color:#ff00ff;font-weight:400">0</span> <br />last = <span style="color:#ff00ff;font-weight:400">0</span> <br />j = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(items)): <br />    <span style="color:#a52a2a;font-weight:700">if</span> items[i] &lt;= boxes[j]: <br />        k += <span style="color:#ff00ff;font-weight:400">1</span><br />        last = items[i] <br />        j += <span style="color:#ff00ff;font-weight:400">1</span> <br />        <span style="color:#a52a2a;font-weight:700">if</span> j == <span style="color:#008a8c;font-weight:400">len</span>(boxes): <br />            <span style="color:#a52a2a;font-weight:700">break</span><br /><span style="color:#008a8c;font-weight:400">print</span>(k, last)</pre></div></p><p>Пример программы, решающей задачу методом двух указателей.</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f: <br />    n, m = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split()) <br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f] <br />items = a[:n] <br />boxes = a[n:] <br />items.sort(reverse=<span style="color:#ff00ff;font-weight:400">True</span>) <br />boxes.sort(reverse=<span style="color:#ff00ff;font-weight:400">True</span>) <br />i = <span style="color:#ff00ff;font-weight:400">0</span> <br />j = <span style="color:#ff00ff;font-weight:400">0</span> <br />k = <span style="color:#ff00ff;font-weight:400">0</span> <br />last = <span style="color:#ff00ff;font-weight:400">0</span> <br /><span style="color:#a52a2a;font-weight:700">while</span> i &lt; <span style="color:#008a8c;font-weight:400">len</span>(items) <span style="color:#a52a2a;font-weight:700">and</span> j &lt; <span style="color:#008a8c;font-weight:400">len</span>(boxes): <br />    <span style="color:#a52a2a;font-weight:700">if</span> items[i] &lt;= boxes[j]: <br />        k += <span style="color:#ff00ff;font-weight:400">1</span> <br />        j += <span style="color:#ff00ff;font-weight:400">1</span> <br />        last = items[i] <br />    i += <span style="color:#ff00ff;font-weight:400">1</span> <br /><span style="color:#008a8c;font-weight:400">print</span>(k, last)</pre></div></p></div><div class='page'><a name="ЕГЭ--27._Анализ_данных_36.html"></a><h1 class='title level-2'>27. Анализ данных</h1><br/><p><h1>Что нужно знать и уметь</h1><ul><li>Читать и понимать сюжет задания.</li><li>Знать понятия кластера, аномалии (выброса), основные метрики расстояний.</li><li>Открывать текстовый файл в табличном процессоре (и Excel, и Calc) так, чтобы каждое число попало в отдельную ячейку.</li><li>Строить в табличном процессоре диаграмму (график) X-Y.</li><li>Составлять уравнения прямых для простой кластеризации.</li><li>Составлять сложные соотношения для проверки границ кластеров или владеть методом DBSCAN для сложной кластеризации.</li></ul></p><p><ol><li>Открываем файл данных в табличном процессоре, строим диаграмму (график) X-Y, определяем границы кластеров.</li><li>Составляем уравнения разделяющих линий.</li><li>Пишем программу для решения:<ol><li>открываем файл данных;</li><li>при использовании границ кластеров проверяем составленные соотношения для отнесения точки к тому или иному кластеру или используем DBSCAN, подбирая значение epsilon.</li><li>для каждого кластера переборным методом ищем центр;</li><li>обрабатываем центры кластеров для получения ответа.</li></ol></li><li>При возможности - визуализируем данные с помощью Черепахи.</li></ol></p><p></p><p>Пример считывания файла данных для двух кластеров с разделяющим соотношением (x &lt; 1) без аномалий:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(file_name) <span style="color:#a020f0;font-weight:400">as</span> f:<br />        clusters = [], [] <span style="color:#0000ff;font-weight:400"># 2 кластера</span><br />        f.readline()<br />        <span style="color:#a52a2a;font-weight:700">for</span> line <span style="color:#a52a2a;font-weight:700">in</span> f:<br />            x, y = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">float</span>, line.replace(<span style="color:#ff00ff;font-weight:400">&#39;,&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;.&#39;</span>).split())<br />            index = <span style="color:#ff00ff;font-weight:400">0</span> <span style="color:#a52a2a;font-weight:700">if</span> x &lt; <span style="color:#ff00ff;font-weight:400">1</span> <span style="color:#a52a2a;font-weight:700">else</span> <span style="color:#ff00ff;font-weight:400">1</span> <span style="color:#0000ff;font-weight:400"># разделение, без аномалий</span><br />            clusters[index].append((x, y))</pre></div></p><p></p><p>Пример считывания файла данных для использования алгоритма DBSCAN:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(file_name) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    f.readline()<br />    data = [<span style="color:#008a8c;font-weight:400">tuple</span>(<span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">float</span>, line.replace(<span style="color:#ff00ff;font-weight:400">&#39;,&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;.&#39;</span>).split())) <span style="color:#a52a2a;font-weight:700">for</span> line <span style="color:#a52a2a;font-weight:700">in</span> f]</pre></div></p><p></p><p>Пример использования алгоритма DBSCAN:</p><p><div class="codebox"><pre>clusters = []<br />local_data = data[:]<br /><span style="color:#a52a2a;font-weight:700">while</span> local_data:<br />    clusters.append([local_data.pop()])<br />    <span style="color:#a52a2a;font-weight:700">for</span> base_point <span style="color:#a52a2a;font-weight:700">in</span> clusters[-<span style="color:#ff00ff;font-weight:400">1</span>]:<br />        <span style="color:#a52a2a;font-weight:700">for</span> point <span style="color:#a52a2a;font-weight:700">in</span> local_data[:]:<br />            <span style="color:#a52a2a;font-weight:700">if</span> dist(base_point, point) &lt; epsilon:<br />                clusters[-<span style="color:#ff00ff;font-weight:400">1</span>].append(point)<br />                local_data.remove(point)</pre></div></p><p>Список кластеров и точек в них - в переменной <code>cluster</code>.</p><p>Для определения евклидова расстояния между точками здесь используется функция <code>dist</code> из модуля <code>math</code>.</p><p></p><p>Пример определения центров кластеров и их обработки для получения ответа с множителем 10000:</p><p><div class="codebox"><pre>centroids = []<br /><span style="color:#a52a2a;font-weight:700">for</span> cluster <span style="color:#a52a2a;font-weight:700">in</span> clusters:<br />    min_d = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br />    <span style="color:#a52a2a;font-weight:700">for</span> x1, y1 <span style="color:#a52a2a;font-weight:700">in</span> cluster:<br />        d = <span style="color:#ff00ff;font-weight:400">0.0</span><br />        <span style="color:#a52a2a;font-weight:700">for</span> x2, y2 <span style="color:#a52a2a;font-weight:700">in</span> cluster:<br />            d += dist((x1, y1), (x2, y2))<br />        <span style="color:#a52a2a;font-weight:700">if</span> d &lt; min_d:<br />            min_d = d<br />            cx, cy = x1, y1<br />    centroids.append((cx, cy))<br />sx, sy = <span style="color:#ff00ff;font-weight:400">0.0</span>, <span style="color:#ff00ff;font-weight:400">0.0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> x, y <span style="color:#a52a2a;font-weight:700">in</span> centroids:<br />    sx += x<br />    sy += y<br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#008a8c;font-weight:400">int</span>(sx / <span style="color:#008a8c;font-weight:400">len</span>(centroids) * <span style="color:#ff00ff;font-weight:400">10000</span>), <span style="color:#008a8c;font-weight:400">int</span>(sy / <span style="color:#008a8c;font-weight:400">len</span>(centroids) * <span style="color:#ff00ff;font-weight:400">10000</span>))</pre></div></p><p></p><p>Пример визуализации, позволяющей убедиться в правильности кластеризации, для трёх кластеров:</p><p><div class="codebox"><pre><span style="color:#a020f0;font-weight:400">from</span> <span style="color:#008a8c;font-weight:400">turtle</span> <span style="color:#a020f0;font-weight:400">import</span> *<br />...<br />up()<br />tracer(<span style="color:#ff00ff;font-weight:400">0</span>)<br />m = <span style="color:#ff00ff;font-weight:400">30</span><br /><span style="color:#a52a2a;font-weight:700">for</span> cluster, color <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">zip</span>(clusters, (<span style="color:#ff00ff;font-weight:400">&#39;blue&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;red&#39;</span>, <span style="color:#ff00ff;font-weight:400">&#39;green&#39;</span>)):<br />    <span style="color:#a52a2a;font-weight:700">for</span> x, y <span style="color:#a52a2a;font-weight:700">in</span> cluster:<br />        goto(x * m, y * m)<br />        dot(<span style="color:#ff00ff;font-weight:400">5</span>, color)<br />update()<br />Screen().exitonclick()</pre></div></p><p>По раскраске точек можно проверить правильность кластеризации.</p></div><div class='page'><a name="ДОПОЛНИТЕЛЬНЫЕ_ЗАДАНИЯ_31.html"></a><h1 class='title level-1'>ДОПОЛНИТЕЛЬНЫЕ ЗАДАНИЯ</h1><br/></div><div class='page'><a name="ДОПОЛНИТЕЛЬНЫЕ_ЗАДАНИЯ--Пути_в_орграфе_32.html"></a><h1 class='title level-2'>Пути в орграфе</h1><br/><p><h1>Определение количества путей</h1><ol><li>Метка исходной вершины - 1.</li><li>Метка вершины - сумма меток входящих.</li><li>Метка целевой вершины - ответ.</li></ol></p><p>Если нужно не проходить через какую-то вершину, то убираем её или заранее ставим ей метку 0.</p><p>Если нужно обязательно пройти через какую-то вершину, то, получив её метку, обнуляем метки всех предыдущих вершин и продолжаем вычисление. Дополнительные способы:<ul><li>умножение числа путей от начальной вершины до обязательной на число путей от обязательной вершины до конечной;</li><li>вычитание числа путей не через обязательную вершину из общего числа путей (сложнее, если несколько условий);</li><li>предварительное удаление лишних рёбер (не всегда визуально понятно, какие лишние).</li></ul></p><p></p><p><h1>Определение самого длинного пути</h1><ol><li>Метка исходной вершины - 0.</li><li>Метка вершины - максимальная метка среди входящих плюс 1.</li><li>Метка целевой вершины - ответ.</li></ol></p><p>Это задание также можно выполнять “на глаз”, но с рассмотрением нескольких вариантов пути и с попытками “улучшить” (удлиннить) найденный путь.</p></div><div class='page'><a name="ДОПОЛНИТЕЛЬНЫЕ_ЗАДАНИЯ--Обработка_числовых_последовательностей_29.html"></a><h1 class='title level-2'>Обработка числовых последовательностей</h1><br/><p><h1>Основные темы заданий</h1><ul><li>Анализ пар, троек элементов последовательности, не обязательно подряд идущих.</li><li>Выбор элементов из пар, троек.</li><li>Поиск подпоследовательностей.</li><li>Взвешенные суммы (стоимость перевозок).</li><li>Разбиение последовательности на две подпоследовательности.</li></ul></p><p></p><p><h1>Что нужно знать</h1><ul><li>Перебор пар и троек элементов (для неэффективных решений).</li><li>Элементы теории чисел: делимость, разложение на простые множители.</li><li>Модулярную арифметику (арифметику остатков).</li><li>Составление комбинаторных формул.</li><li>Использование одномерных и двумерных массивов статистики.</li><li>Префиксные суммы.</li><li>Метод двух указателей, метод скользящего окна.</li><li>Способы корректировки получаемых значений без их полного пересчёта.</li></ul></p><p></p><p><h1>Общий порядок решения</h1><ol><li>Читаем и понимаем условие.</li><li>Изучаем пример.</li><li>Читаем и понимаем условие ещё раз, с учётом примера.</li><li>Пишем неэффективную программу, правильно работающую на данных из примера.</li><li>Запускаем неэффективную программу на данных из файла A (небольшого). Получаем 1-е число в ответе.</li><li>Пишем эффективную программу, правильно работающую на данных из примера.</li><li>Запускаем эффективную программу на данных из файла A (небольшого). Проверяем 1-е число в ответе.</li><li>Запускаем эффективную программу на данных из файла B (большого). Получаем 2-е число в ответе.</li></ol></p><p></p><p><h1>Виды заданий</h1></p><p><h2>Анализ пар элементов с произведением, делящимся на N</h2></p><p><h3>Неэффективное решение</h3></p><p>Пример программы для неэффективного решения, связанного с перебором всех возможных пар элементов (определение количества пар):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />k = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n - <span style="color:#ff00ff;font-weight:400">1</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i + <span style="color:#ff00ff;font-weight:400">1</span>, n):<br />        <span style="color:#a52a2a;font-weight:700">if</span> a[i] * a[j] % <span style="color:#ff00ff;font-weight:400">7</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />            k += <span style="color:#ff00ff;font-weight:400">1</span><br /><span style="color:#008a8c;font-weight:400">print</span>(k)</pre></div></p><p>Пример программы для неэффективного решения, связанного с перебором всех возможных пар элементов (вычисление максимального произведения элементов пары):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n - <span style="color:#ff00ff;font-weight:400">1</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i + <span style="color:#ff00ff;font-weight:400">1</span>, n):<br />        <span style="color:#a52a2a;font-weight:700">if</span> a[i] * a[j] % <span style="color:#ff00ff;font-weight:400">15</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />            m = <span style="color:#008a8c;font-weight:400">max</span>(m, a[i] * a[j])<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p><h3>Эффективное решение</h3></p><p>Эффективное решение основано на сборе и использовании статистик делимости элементов последовательности.</p><p>Произведение двух чисел делится на N тогда и только тогда, когда все его простые множители присутствуют совокупно в обоих числах. В частности:<ul><li>число 7 простое, поэтому произведение двух чисел делится на 7, если хотя бы одно из чисел делится на 7;</li><li>число 4 раскладывается на простые множители как 2*2, поэтому произведение двух чисел делится на 4, если множители 2 и 2 присутствуют в перемножаемых числах: либо хотя бы одно из чисел делится на 4, либо каждое из чисел делится на 2;</li><li>число 6 раскладывается на простые множители как 2*3, поэтому произведение двех чисел делится на 6, если множители 2 и 3 присутствуют в перемножаемых числах: либо хотя бы одно из чисел делится на 6, либо одно из чисел делится на 2, а второе - на 3.</li></ul></p><p>Числа, которые раскладываются на большее число простых множителей, в условиях задач не предлагались.</p><p>Таким образом, нужно учитывать элементы последовательности, делящиеся на каждое допустимое число. В частности:<ul><li>для деления произведения на 11 это делимость только на 11;</li><li>для деления произведения на 9 это делимость на 3 и на 9;</li><li>для деления произведения на 10 это делимость на 2, на 5 и на 10.</li></ul></p><p>Возможные виды статистик:<ul><li>Если требуется найти количество пар, то нужны количества элементов, делящихся на каждое из допустимых чисел.</li><li>Если требуется найти максимальное/минимальное произведение пары, то нужно нужны максимальные/минимальные значения элементов, делящиеся на на каждое из допустимых чисел. При этом, если оба элемента могут делиться на одно и то же число, то нужны два максимальных/минимальных значения таких элементов. Также нужно максимальное число, которое не делится ни на одно из нужных чисел.</li></ul></p><p>Ни один элемент не должен попадать более чем в одну статистику. Например, если произведение в паре должно делиться на 10, то нужна статистика по делимости на 10, 5 и 2. Если элемент делится на 10, то оно он может попасть в статистику делимости только на 10. Учёт элементов в статистиках делимости на 5 и на 2 предполагает, что они не делятся на 10.</p><p>Статистики можно использовать двумя способами:<ul><li>сразу во время прохода по последовательности, накапливая результат; в этом случае текущее число считается вторым элементом пар, а необходимые данные о подходящих первых элементах (их количество, максимальное/минимальное значение) берутся из статистики;</li><li>после прохода по последовательности, создав комбинаторную формулу.</li></ul></p><p>Пример программы, определяющей количество пар с произведением, делящимся на 7, с комбинаторной формулой:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />k7 = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a:<br />    <span style="color:#a52a2a;font-weight:700">if</span> x % <span style="color:#ff00ff;font-weight:400">7</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        k7 += <span style="color:#ff00ff;font-weight:400">1</span><br /><span style="color:#008a8c;font-weight:400">print</span>(k7 * (k7 - <span style="color:#ff00ff;font-weight:400">1</span>) // <span style="color:#ff00ff;font-weight:400">2</span> + k7 * (n - k7))</pre></div></p><p>Пример программы, определяющей количество пар с произведением, делящимся на 6, с комбинаторной формулой:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />k2 = k3 = k6 = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a:<br />    <span style="color:#a52a2a;font-weight:700">if</span> x % <span style="color:#ff00ff;font-weight:400">6</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        k6 += <span style="color:#ff00ff;font-weight:400">1</span><br />    <span style="color:#a52a2a;font-weight:700">elif</span> x % <span style="color:#ff00ff;font-weight:400">3</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        k3 += <span style="color:#ff00ff;font-weight:400">1</span><br />    <span style="color:#a52a2a;font-weight:700">elif</span> x % <span style="color:#ff00ff;font-weight:400">2</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        k2 += <span style="color:#ff00ff;font-weight:400">1</span><br /><span style="color:#008a8c;font-weight:400">print</span>(k6 * (k6 - <span style="color:#ff00ff;font-weight:400">1</span>) // <span style="color:#ff00ff;font-weight:400">2</span> + k6 * (n - k6) + k2 * k3)</pre></div></p><p>Пример программы, определяющей количество пар с произведением, делящимся на 6, с использованием статистики при проходе по последовательности:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />k1 = k2 = k3 = k6 = s = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a:<br />    <span style="color:#a52a2a;font-weight:700">if</span> x % <span style="color:#ff00ff;font-weight:400">6</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        s += k1 + k2 + k3 + k6<br />        k6 += <span style="color:#ff00ff;font-weight:400">1</span><br />    <span style="color:#a52a2a;font-weight:700">elif</span> x % <span style="color:#ff00ff;font-weight:400">3</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        s += k2 + k6<br />        k3 += <span style="color:#ff00ff;font-weight:400">1</span><br />    <span style="color:#a52a2a;font-weight:700">elif</span> x % <span style="color:#ff00ff;font-weight:400">2</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        s += k3 + k6<br />        k2 += <span style="color:#ff00ff;font-weight:400">1</span><br />    <span style="color:#a52a2a;font-weight:700">else</span>:<br />        s += k6<br />        k1 += <span style="color:#ff00ff;font-weight:400">1</span><br /><span style="color:#008a8c;font-weight:400">print</span>(s)</pre></div></p><p>Пример программы, определяющей максимальное произведение пары, делящееся на 6, с использованием статистики после прохода по последовательности:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />m = m2 = m3 = m6a = m6b = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a:<br />    <span style="color:#a52a2a;font-weight:700">if</span> x % <span style="color:#ff00ff;font-weight:400">6</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        <span style="color:#a52a2a;font-weight:700">if</span> x &gt; m6a:<br />            m6a, m6b = x, m6a<br />        <span style="color:#a52a2a;font-weight:700">else</span>:<br />            m6b = <span style="color:#008a8c;font-weight:400">max</span>(m6b, x)<br />    <span style="color:#a52a2a;font-weight:700">elif</span> x % <span style="color:#ff00ff;font-weight:400">3</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        m3 = <span style="color:#008a8c;font-weight:400">max</span>(m3, x)<br />    <span style="color:#a52a2a;font-weight:700">elif</span> x % <span style="color:#ff00ff;font-weight:400">2</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        m2 = <span style="color:#008a8c;font-weight:400">max</span>(m2, x)<br />    <span style="color:#a52a2a;font-weight:700">else</span>:<br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, x)<br /><span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#008a8c;font-weight:400">max</span>(m6a * m6b, m6a * m, m6a * m3, m6a * m2, m2 * m3))</pre></div></p><p>Пример программы, определяющей максимальное произведение пары, делящееся на 6, с использованием статистики при проходе по последовательности:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />m = m1 = m2 = m3 = m6 = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a:<br />    <span style="color:#a52a2a;font-weight:700">if</span> x % <span style="color:#ff00ff;font-weight:400">6</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, x * m6, x * m3, x * m2, x * m1)<br />        m6 = <span style="color:#008a8c;font-weight:400">max</span>(m6, x)<br />    <span style="color:#a52a2a;font-weight:700">elif</span> x % <span style="color:#ff00ff;font-weight:400">3</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, x * m6, x * m2)<br />        m3 = <span style="color:#008a8c;font-weight:400">max</span>(m3, x)<br />    <span style="color:#a52a2a;font-weight:700">elif</span> x % <span style="color:#ff00ff;font-weight:400">2</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, x * m6, x * m3)<br />        m2 = <span style="color:#008a8c;font-weight:400">max</span>(m2, x)<br />    <span style="color:#a52a2a;font-weight:700">else</span>:<br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, x * m6)<br />        m1 = <span style="color:#008a8c;font-weight:400">max</span>(m1, x)<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p><h2>Анализ пар элементов с суммой, делящейся на N</h2></p><p><h3>Неэффективное решение</h3></p><p>Пример программы для неэффективного решения, связанного с перебором всех возможных пар элементов (определение количества пар):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />k = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n - <span style="color:#ff00ff;font-weight:400">1</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i + <span style="color:#ff00ff;font-weight:400">1</span>, n):<br />        <span style="color:#a52a2a;font-weight:700">if</span> (a[i] + a[j]) % <span style="color:#ff00ff;font-weight:400">10</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />            k += <span style="color:#ff00ff;font-weight:400">1</span><br /><span style="color:#008a8c;font-weight:400">print</span>(k)</pre></div></p><p>Пример программы для неэффективного решения, связанного с перебором всех возможных пар элементов (вычисление максимальной суммы элементов пары):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n - <span style="color:#ff00ff;font-weight:400">1</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i + <span style="color:#ff00ff;font-weight:400">1</span>, n):<br />        <span style="color:#a52a2a;font-weight:700">if</span> (a[i] + a[j]) % <span style="color:#ff00ff;font-weight:400">24</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />            m = <span style="color:#008a8c;font-weight:400">max</span>(m, a[i] + a[j])<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p><h3>Эффективное решение</h3></p><p>Эффективное решение основано на сборе и использовании статистик делимости элементов последовательности.</p><p>Сумма двух чисел делится на N тогда и только тогда, когда сумма их остатков от деления на N сама делится на N. Это возможно в двух случаях:<ul><li>сумма остатков равна N;</li><li>оба остатка равны 0.</li></ul></p><p>Назовём такие остатки парными.</p><p>Таким образом, нужно учитывать элементы последовательности, имеющие все возможные остатки от деления на N.</p><p>Статистики можно использовать двумя способами:<ul><li>сразу во время прохода по последовательности, накапливая результат; в этом случае текущее число считается вторым элементом пар, а необходимые данные о подходящих первых элементах (их количество, максимальное/минимальное значение) берутся из статистики;</li><li>после прохода по последовательности, используя комбинаторный подход; это менее предпочтительный вариант, т. к. менее универсальный и более сложный, особенно для чётных чисел (одинаковые парные остатки могут быть не только нулевые, но и равные N/2).</li></ul></p><p>Способ получения остатков от деления, принятый в Python для отрицательных чисел, соотвествует способу получения парных остатков.</p><p>Пример программы, определяющей количество пар с суммой, делящейся на 7, с использованием статистики при проходе по последовательности:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />d = <span style="color:#ff00ff;font-weight:400">7</span><br />stat = [<span style="color:#ff00ff;font-weight:400">0</span>] * d<br />k = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a:<br />    k += stat[(-x) % d]<br />    stat[x % d] += <span style="color:#ff00ff;font-weight:400">1</span><br /><span style="color:#008a8c;font-weight:400">print</span>(k)</pre></div></p><p>Пример программы, определяющей количество пар с суммой, делящейся на 10 (с учётом чётности числа), с использованием статистики после прохода по последовательности:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />d = <span style="color:#ff00ff;font-weight:400">10</span><br />stat = [<span style="color:#ff00ff;font-weight:400">0</span>] * d<br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a:<br />    stat[x % d] += <span style="color:#ff00ff;font-weight:400">1</span><br />k = stat[<span style="color:#ff00ff;font-weight:400">0</span>] * (stat[<span style="color:#ff00ff;font-weight:400">0</span>] - <span style="color:#ff00ff;font-weight:400">1</span>) // <span style="color:#ff00ff;font-weight:400">2</span><br /><span style="color:#a52a2a;font-weight:700">if</span> d % <span style="color:#ff00ff;font-weight:400">2</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />    k += stat[d // <span style="color:#ff00ff;font-weight:400">2</span>] * (stat[d // <span style="color:#ff00ff;font-weight:400">2</span>] - <span style="color:#ff00ff;font-weight:400">1</span>) // <span style="color:#ff00ff;font-weight:400">2</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, (d + <span style="color:#ff00ff;font-weight:400">1</span>) // <span style="color:#ff00ff;font-weight:400">2</span>):<br />    k += stat[i] * stat[-i]<br /><span style="color:#008a8c;font-weight:400">print</span>(k)</pre></div></p><p>Пример программы, определяющей максимальную сумму пары, делящуюся на 16, с использованием статистики при проходе по последовательности:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />d = <span style="color:#ff00ff;font-weight:400">16</span><br />stat = [<span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)] * d<br />m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a:<br />    m = <span style="color:#008a8c;font-weight:400">max</span>(m, x + stat[(-x) % d])<br />    stat[x % d] = <span style="color:#008a8c;font-weight:400">max</span>(stat[x % d], x)<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p><h2>Анализ пар элементов с разностью, делящейся на N, причём первый элемент всегда больше/меньше второго</h2></p><p><h3>Неэффективное решение</h3></p><p>Пример программы для неэффективного решения, связанного с перебором всех возможных пар элементов (вычисление максимальной разности элементов пары, причём первый элемент меньше второго):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n - <span style="color:#ff00ff;font-weight:400">1</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i + <span style="color:#ff00ff;font-weight:400">1</span>, n):<br />        <span style="color:#a52a2a;font-weight:700">if</span> a[i] &lt; a[j] <span style="color:#a52a2a;font-weight:700">and</span> (a[j] - a[i]) % <span style="color:#ff00ff;font-weight:400">76</span> == <span style="color:#ff00ff;font-weight:400">0</span>:<br />            m = <span style="color:#008a8c;font-weight:400">max</span>(m, a[j] - a[i])<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p>Условие на то, чтобы первый элемент был меньше второго, существенно для эффективного решения.</p><p></p><p><h3>Эффективное решение</h3></p><p>Эффективное решение основано на сборе и использовании статистик делимости элементов последовательности.</p><p>Разность двух чисел делится на N тогда и только тогда, когда разность их остатков от деления на N сама делится на N, т. е. остатки от деления элементов на N равны между собой.</p><p>Таким образом, нужно учитывать элементы последовательности, имеющие все возможные остатки от деления на N.</p><p>Статистику в данном случае лучше использовать сразу во время прохода по последовательности; в этом случае текущее число считается вторым элементом пар, а необходимые данные о подходящих первых элементах берутся из статистики. Для получения максимальной разности при условии, что первый элемент меньше второго, в статистику целесообразно записывать минимальные числа со всеми остатками от деления на N. Таким образом, во время прохода по последовательности числа в статистике будут заменяться ещё меньшими числами, и это будет способствовать определению максимально возможной разности. </p><p>Пример программы, определяющей максимальную разность элементов пары, делящуюся на 12, с использованием статистики при проходе по последовательности:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />d = <span style="color:#ff00ff;font-weight:400">12</span><br />stat = [<span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)] * d<br />m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a:<br />    <span style="color:#a52a2a;font-weight:700">if</span> stat[x % d] &lt; x:<br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, x - stat[x % d])<br />    stat[x % d] = <span style="color:#008a8c;font-weight:400">min</span>(stat[x % d], x)<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p><h2>Анализ пар элементов с суммой, делящейся на N, и дополнительными условиями</h2></p><p>Виды дополнительных условий:<ul><li>расстояние между элементами в последовательности не менее заданного;</li><li>чётность или нечётность суммы (в дополнение к делимости суммы или разности на N).</li></ul></p><p>Учёт этих условий в неэффективном решении сводится к добавлению условий при анализе всех возможных пар.</p><p>Рассмотрим учёт условий в эффективной программе.</p><p>Ограничение на минимальное расстояние между элементами пар может быть учтено при использовании статистик делимости во время прохода по последовательности. Оно учитывается следующим образом: в статистику вносится не текущий элемент последовательности, а тот, который находится ровно на заданном расстоянии перед ним.</p><p>Ограничение на чётность или нечётность суммы чисел заставляет учитывать элементы последовательности в разрезе не только их остатков от деления на N, но и их остатков от деления на 2. Статистика становится двумерной.</p><p>При инициализации двумерного массива статистики (списка списков) нужно учесть особенности работы Python с переменными.</p><p>Пример неверной инициализации списка списков (будет создано <em>y</em> ссылок на один список):</p><p><div class="codebox"><pre>stat = [[<span style="color:#ff00ff;font-weight:400">0</span>] * x] * y</pre></div></p><p>Пример верной инициализации списка списков (будет создан список независимых списков):</p><p><div class="codebox"><pre>stat = [[<span style="color:#ff00ff;font-weight:400">0</span>] * x <span style="color:#a52a2a;font-weight:700">for</span> _ <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(y)]</pre></div></p><p>Пример эффективной программы, учитывающей оба дополнительных условия (нечётность суммы, делимость разности на N, расстояние между элементами не менее заданного:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />d = <span style="color:#ff00ff;font-weight:400">15</span> <span style="color:#0000ff;font-weight:400"># На что должна делиться разность</span><br />p = <span style="color:#ff00ff;font-weight:400">7</span> <span style="color:#0000ff;font-weight:400"># Минимальное расстояние между элементами</span><br />stat = [[<span style="color:#ff00ff;font-weight:400">0</span>, <span style="color:#ff00ff;font-weight:400">0</span>] <span style="color:#a52a2a;font-weight:700">for</span> _ <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(d)]<br />k = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#008a8c;font-weight:400">len</span>(a)):<br />    <span style="color:#a52a2a;font-weight:700">if</span> i &gt;= p:<br />        stat[a[i - p] % d][a[i - p] % <span style="color:#ff00ff;font-weight:400">2</span>] += <span style="color:#ff00ff;font-weight:400">1</span><br />    k += stat[a[i] % d][<span style="color:#ff00ff;font-weight:400">1</span> - a[i] % <span style="color:#ff00ff;font-weight:400">2</span>]<br /><span style="color:#008a8c;font-weight:400">print</span>(k)</pre></div></p><p></p><p><h2>Выбор небольшого числа элементов с расстоянием между элементами не менее заданного и наибольшей/наименьшей суммой/произведением</h2></p><p><h3>Неэффективное решение</h3></p><p>Пример программы для неэффективного решения, связанного с перебором всех возможных пар элементов (вычисление максимального произведения элементов пары с заданным минимальным расстоянием):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n - <span style="color:#ff00ff;font-weight:400">6</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i + <span style="color:#ff00ff;font-weight:400">6</span>, n):<br />        m = <span style="color:#008a8c;font-weight:400">max</span>(m, a[i] + a[j])<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p>Пример программы для неэффективного решения, связанного с перебором всех возможных троек элементов (вычисление максимальной суммы элементов тройки с заданным минимальным расстоянием):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n - <span style="color:#ff00ff;font-weight:400">12</span>):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i + <span style="color:#ff00ff;font-weight:400">6</span>, n):<br />        <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(j + <span style="color:#ff00ff;font-weight:400">6</span>, n):<br />            m = <span style="color:#008a8c;font-weight:400">max</span>(m, a[i] + a[j] + a[k])<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p><h3>Эффективное решение</h3></p><p>Эффективное решение основано на поддержании нескольких значений в процессе прохода по элементам последовательности, количество которых определяется количеством выбираемых элементов. Примеры для максимальной суммы чисел:<ul><li>при выборе 1 числа:<ul><li>собственно текущее число (&quot;максимальная сумма одного числа&quot;) - оно пойдёт в результат, это обычный максимальный элемент последовательности;</li></ul></li><li>при выборе 2 чисел:<ul><li>первое число - максимальное число (&quot;максимальная сумма одного числа&quot;) среди находящихся на расстоянии не менее заданного от текущего;</li><li>второе число - максимальная сумма двух чисел, обновляется по первому числу и текущему числу, это пойдёт в результат;</li></ul></li><li>при выборе 3 чисел:<ul><li>первое число - максимальное число (&quot;максимальная сумма одного числа&quot;) среди находящихся на расстоянии не менее двух заданных расстояний от текущего;</li><li>второе число - максимальная сумма двух чисел, обновляется по первому числу и числу, находящемуся на расстоянии не менее заданного от текущего числа;</li><li>третье число - максимальная сумма трёх чисел, обновляется по второму числу и текущему числу, это пойдёт в результат.</li></ul></li></ul></p><p>При большем количестве чисел для выбора соответственно увеличивается число показателей, и они используются аналогично.</p><p>Данный способ использования показателей гарантирует, что:<ul><li>каждое число будет учтено в сумме или произведении не больше одного раза;</li><li>расстояние между элементами суммы или произведения в последовательности не менее заданного.</li></ul></p><p>Пример программы для эффективного решения (вычисление максимального произведения элементов пары с заданным минимальным расстоянием):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />d = <span style="color:#ff00ff;font-weight:400">100</span><br />m = mp = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(d, n):<br />    mp = <span style="color:#008a8c;font-weight:400">max</span>(mp, a[i - d])<br />    m = <span style="color:#008a8c;font-weight:400">max</span>(m, a[i] * mp)<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p>Пример программы для эффективного решения (вычисление максимальной суммы элементов тройки с заданным минимальным расстоянием):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />d = <span style="color:#ff00ff;font-weight:400">100</span><br />m = mp = mpp = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">2</span> * d, n):<br />    mpp = <span style="color:#008a8c;font-weight:400">max</span>(mpp, a[i - <span style="color:#ff00ff;font-weight:400">2</span> * d])<br />    mp = <span style="color:#008a8c;font-weight:400">max</span>(mp, a[i - d] + mpp)<br />    m = <span style="color:#008a8c;font-weight:400">max</span>(m, a[i] + mp)<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p>Пример <strong>неправильной</strong> программы эффективного решения (как не надо делать):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />d = <span style="color:#ff00ff;font-weight:400">100</span><br />ms = m = mp = mpp = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">2</span> * d, n):<br />    mpp = <span style="color:#008a8c;font-weight:400">max</span>(mpp, a[i - <span style="color:#ff00ff;font-weight:400">2</span> * d])<br />    mp = <span style="color:#008a8c;font-weight:400">max</span>(mp, a[i - d])<br />    m = <span style="color:#008a8c;font-weight:400">max</span>(m, a[i])<br />    ms = <span style="color:#008a8c;font-weight:400">max</span>(ms, m + mp + mpp)<br /><span style="color:#008a8c;font-weight:400">print</span>(ms)</pre></div></p><p>Проблема этой программы в том, что одно и то же число, если оно достаточно большое, может оказаться значением двух или трёх показателей и будет учтено в сумме больше одного раза, что может дать неверный ответ.</p><p></p><p><h2>Выбор элементов из множества пар или троек</h2></p><p>Дан набор пар (троек чисел). Требуется выбрать из каждой пары (тройки) ровно одно число так, чтобы сумма выбранных чисел не делилась на заданное число и была при этом максимально (минимально) возможной.</p><p>Неэффективное решение задачи затруднено даже для относительно небольших значений N, т. к. имеет сложность по времени 2<sup>N</sup>. Для неэффективного решения предлагались лишь задачи с N&lt;=10, допускающие перебор всех способов выбора чисел с каскадом N вложенных циклов.</p><p>Рассмотрим эффективное решение следующей конкретной задачи: дан набор пар чисел, требуется выбрать из каждой пары ровно одно число так, чтобы сумма выбранных чисел не делилась на 17 и была при этом максимально возможной; в ответе записать полученную сумму.</p><p>Эффективное решение основано на следующих принципах:<ul><li>если выбрать из каждой пары максимальное число, то их сумма будет максимально возможной для данного набора пар;</li><li>однако максимально возможная сумма может делиться на 17;</li><li>полученную максимальную сумму можно скорректировать так, чтобы она перестала делиться на 17: для этого нужно в одной из пар вместо большего числа взять меньшее;</li><li>пару, за счёт которой будет корректироваться результат, нужно выбрать по двум условиям:<ul><li>разность элементов пары минимально возможна;</li><li>разность элементов пары не делится на 17;</li></ul></li><li>такой выбор пары позволит:<ul><li>“ухудшить” (уменьшить) максимальную сумму, но на как можно меньшую величину;</li><li>заставить сумму не делиться на 17, т. к. при разность исходной суммы, делящейся на 17, и разности элементов пары, не делящейся на 17, не делится на 17.</li></ul></li></ul></p><p>При решении задачи обработку пар (троек) чисел удобнее производить во время их чтения из файла.</p><p>Пример эффективного решения рассмотренной задачи:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    s = <span style="color:#ff00ff;font-weight:400">0</span><br />    d = <span style="color:#ff00ff;font-weight:400">17</span><br />    m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br />    <span style="color:#a52a2a;font-weight:700">for</span> _ <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />        a, b = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split())<br />        s += <span style="color:#008a8c;font-weight:400">max</span>(a, b)<br />        <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">abs</span>(a - b) % d != <span style="color:#ff00ff;font-weight:400">0</span>:<br />            m = <span style="color:#008a8c;font-weight:400">min</span>(m, <span style="color:#008a8c;font-weight:400">abs</span>(a - b))<br /><span style="color:#a52a2a;font-weight:700">if</span> s % d != <span style="color:#ff00ff;font-weight:400">0</span>:<br />    <span style="color:#008a8c;font-weight:400">print</span>(s)<br /><span style="color:#a52a2a;font-weight:700">else</span>:<br />    <span style="color:#008a8c;font-weight:400">print</span>(s - m)</pre></div>  </p><p>При определении минимальной суммы особенности такие:<ul><li>для суммирования нужно выбирать меньшие числа в парах;</li><li>корректировать сумму нужно не вычитанием, а прибавлением минимальной разности элементов пары;</li><li>разность элементов пары для корректировки всё ещё должна быть минимальной.</li></ul></p><p>При выборе элементов из троек решение аналогично, но нужно искать минимальную разность между максимальным числом в тройке и каким-либо из двух остальных. Оба варианта важны, т. к. разность между максимальным и средним числом в тройке хотя и не больше разности между максимальным и минимальным, может не подходить по критерию делимости.</p><p>Пример эффективного решения задачи с выбором элемента из троек:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    s = <span style="color:#ff00ff;font-weight:400">0</span><br />    d = <span style="color:#ff00ff;font-weight:400">17</span><br />    m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br />    <span style="color:#a52a2a;font-weight:700">for</span> _ <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />        a, b, c = <span style="color:#008a8c;font-weight:400">sorted</span>(<span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split()))<br />        s += c<br />        <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">abs</span>(c - a) % d != <span style="color:#ff00ff;font-weight:400">0</span>:<br />            m = <span style="color:#008a8c;font-weight:400">min</span>(m, <span style="color:#008a8c;font-weight:400">abs</span>(c - a))<br />        <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">abs</span>(c - b) % d != <span style="color:#ff00ff;font-weight:400">0</span>:<br />            m = <span style="color:#008a8c;font-weight:400">min</span>(m, <span style="color:#008a8c;font-weight:400">abs</span>(c - b))<br /><span style="color:#a52a2a;font-weight:700">if</span> s % d != <span style="color:#ff00ff;font-weight:400">0</span>:<br />    <span style="color:#008a8c;font-weight:400">print</span>(s)<br /><span style="color:#a52a2a;font-weight:700">else</span>:<br />    <span style="color:#008a8c;font-weight:400">print</span>(s - m)</pre></div></p><p></p><p><h2>Перевозки: прямое шоссе, стоимость перевозок пропорциональна расстояниям</h2></p><p>Типовой сюжет: в некоторых точках прямого шоссе расположены пункты приёма биоматериалов. В одном из пунктов нужно построить лабораторию так, чтобы суммарная стоимость транспортировки биоматериалов в лабораторию была минимально возможной. Стоимость транспортировки биоматериалов на некоторое расстояние равна произведению количества биоматериалов на расстояние.</p><p>Исходные данные: количество пунктов N, затем N пар чисел: местоположение на шоссе и количество биоматериала. </p><p>Количество биоматериала, как правило, дано в одних единицах измерения (пробирки), а для вычисления имеют значение другие единицы (контейнеры). Можно осуществить перевод в другие единицы измерения во время считывания данных. Если получается нецелое количество контейнеров, то его нужно округлить вверх.</p><p></p><p><h3>Неэффективное решение</h3></p><p>Неэффективное решение основано на переборе пунктов на шоссе в качестве возможных местоположений лаборатории, причём для каждого расположения заново полностью рассчитывается стоимость транспортировки всех биоматериалов.</p><p>Пример неэффективного решения:</p><p><div class="codebox"><pre><span style="color:#0000ff;font-weight:400"># Чтение данных</span><br /><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = []<br />    d = <span style="color:#ff00ff;font-weight:400">25</span> <span style="color:#0000ff;font-weight:400"># Вместимость контейнера с пробирками</span><br />    <span style="color:#a52a2a;font-weight:700">for</span> _ <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />        x, y = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split())<br />        y = y // d + (<span style="color:#ff00ff;font-weight:400">0</span> <span style="color:#a52a2a;font-weight:700">if</span> y % d == <span style="color:#ff00ff;font-weight:400">0</span> <span style="color:#a52a2a;font-weight:700">else</span> <span style="color:#ff00ff;font-weight:400">1</span>)<br />        a.append((x, y))<br /><span style="color:#0000ff;font-weight:400"># Перебор расположений лаборатории</span><br /><span style="color:#0000ff;font-weight:400"># с полным пересчётом стоимостей транспортировки</span><br />m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />    s = <span style="color:#ff00ff;font-weight:400">0</span><br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />        s += a[j][<span style="color:#ff00ff;font-weight:400">1</span>] * <span style="color:#008a8c;font-weight:400">abs</span>(a[j][<span style="color:#ff00ff;font-weight:400">0</span>] - a[i][<span style="color:#ff00ff;font-weight:400">0</span>])<br />    m = <span style="color:#008a8c;font-weight:400">min</span>(m, s)<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p><h3>Эффективное решение</h3></p><p>Эффективное решение основано на однократном вычислении общей стоимости транспортировки для какого-нибудь одного (обычно первого) местоположения лаборатории, а при рассмотрении нового местоположения лаборатории - лишь на корректировке предыдущего значения стоимости.</p><p>При рассмотрении расположений лаборатории по порядку пунктов на шоссе можно заметить, что каждое новое расположение как бы сдвигает лабораторию на расстояние между предыдущим и текущим населённым пунктом; соответственно, транспортировка всего каждого контейнера с одной стороны от лаборатории становится на это расстояние дороже, а с другой - дешевле. Также меняется и само количество контейнеров с каждой стороны от лаборатории.</p><p>Таким образом, для корректировки стоимости нужно перебрать возможные местоположения лаборатории пройти, поддерживая значения количества контейнеров с обеих сторон от лаборатории.</p><p>Пример эффективного решения:</p><p><div class="codebox"><pre><span style="color:#0000ff;font-weight:400"># Чтение данных</span><br /><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = []<br />    d = <span style="color:#ff00ff;font-weight:400">25</span> <span style="color:#0000ff;font-weight:400"># Вместимость контейнера с пробирками</span><br />    <span style="color:#a52a2a;font-weight:700">for</span> _ <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />        x, y = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split())<br />        y = y // d + (<span style="color:#ff00ff;font-weight:400">0</span> <span style="color:#a52a2a;font-weight:700">if</span> y % d == <span style="color:#ff00ff;font-weight:400">0</span> <span style="color:#a52a2a;font-weight:700">else</span> <span style="color:#ff00ff;font-weight:400">1</span>)<br />        a.append((x, y))<br /><span style="color:#0000ff;font-weight:400"># Вычисление стоимости транспортировки</span><br /><span style="color:#0000ff;font-weight:400"># для начального расположения лаборатории</span><br />s = s1 = s2 = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, n):<br />    s += (a[i][<span style="color:#ff00ff;font-weight:400">0</span>] - a[<span style="color:#ff00ff;font-weight:400">0</span>][<span style="color:#ff00ff;font-weight:400">0</span>]) * a[i][<span style="color:#ff00ff;font-weight:400">1</span>]<br />    s2 += a[i][<span style="color:#ff00ff;font-weight:400">1</span>]<br />ms = s<br /><span style="color:#0000ff;font-weight:400"># Перебор расположений лаборатории с корретировками</span><br /><span style="color:#0000ff;font-weight:400"># стоимости транспортировки</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, n):<br />    s1 += a[i - <span style="color:#ff00ff;font-weight:400">1</span>][<span style="color:#ff00ff;font-weight:400">1</span>]<br />    s += (a[i][<span style="color:#ff00ff;font-weight:400">0</span>] - a[i - <span style="color:#ff00ff;font-weight:400">1</span>][<span style="color:#ff00ff;font-weight:400">0</span>]) * (s1 - s2)<br />    s2 -= a[i][<span style="color:#ff00ff;font-weight:400">1</span>]<br />    ms = <span style="color:#008a8c;font-weight:400">min</span>(ms, s)<br /><span style="color:#008a8c;font-weight:400">print</span>(ms)</pre></div></p><p></p><p><h3>Эффективное решение (более простое)</h3></p><p>Если позволяет размер исходных данных, то решение можно упростить, введя фиктивные населённые пункты - пункты, расположенные на остальных километрах шоссе, содержащие нулевое количество контейнеров. Их наличие не повлияет на общую стоимость транспортировки, так как стоимость “транспортировки” 0 контейнеров на любое расстояние равна 0, однако сделает все нужные расстояния равными единице, что упростит вычисления.</p><p>Пример эффективного решения:</p><p><div class="codebox"><pre><span style="color:#0000ff;font-weight:400"># Чтение данных</span><br /><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    k = <span style="color:#ff00ff;font-weight:400">100001</span> <span style="color:#0000ff;font-weight:400"># Длина шоссе в километрах + 1</span><br />    a = [<span style="color:#ff00ff;font-weight:400">0</span>] * k<br />    d = <span style="color:#ff00ff;font-weight:400">25</span> <span style="color:#0000ff;font-weight:400"># Вместимость контейнера с пробирками</span><br />    <span style="color:#a52a2a;font-weight:700">for</span> _ <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />        x, y = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split())<br />        a[x] = (y - <span style="color:#ff00ff;font-weight:400">1</span>) // d + <span style="color:#ff00ff;font-weight:400">1</span><br /><span style="color:#0000ff;font-weight:400"># Вычисление стоимости транспортировки</span><br /><span style="color:#0000ff;font-weight:400"># для начального расположения лаборатории</span><br />p = s1 = <span style="color:#ff00ff;font-weight:400">0</span><br />s2 = <span style="color:#008a8c;font-weight:400">sum</span>(a[<span style="color:#ff00ff;font-weight:400">1</span>:])<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, k):<br />    p += i * a[i]<br />m = p<br /><span style="color:#0000ff;font-weight:400"># Перебор расположений лаборатории с корретировками</span><br /><span style="color:#0000ff;font-weight:400"># стоимости транспортировки</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, k):<br />    s1 += a[i - <span style="color:#ff00ff;font-weight:400">1</span>]<br />    p += s1 - s2<br />    s2 -= a[i]<br />    m = <span style="color:#008a8c;font-weight:400">min</span>(m, p)<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p></p><p><h2>Перевозки: кольцевая дорога, стоимость перевозок пропорциональна расстояниям</h2></p><p>Типовой сюжет: на каждом километре кольцевого шоссе расположены пункты сбора мусора. В одном из пунктов нужно построить мусороперерабатывающий завод так, чтобы суммарная стоимость транспортировки мусора на завод была минимально возможной. Стоимость транспортировки мусора на некоторое расстояние равна произведению количества мусора на расстояние в километрах.</p><p>Исходные данные: количество пунктов N, затем N чисел: местоположение и количество мусора в каждом пункте по порядку расположения пунктов. </p><p></p><p><h3>Неэффективное решение</h3></p><p>Неэффективное решение основано на переборе пунктов на шоссе в качестве возможных местоположений завода, причём для каждого расположения заново полностью рассчитывается стоимость транспортировки всего мусора.</p><p>Пример неэффективного решения:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />    s = <span style="color:#ff00ff;font-weight:400">0</span><br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />        s += a[j] * <span style="color:#008a8c;font-weight:400">min</span>(<span style="color:#008a8c;font-weight:400">abs</span>(j - i), n - <span style="color:#008a8c;font-weight:400">abs</span>(j - i))<br />    m = <span style="color:#008a8c;font-weight:400">min</span>(m, s)<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p><h3>Эффективное решение</h3></p><p>Идея эффективного решения основана на однократном расчёте общей стоимости транспортировки при нахождении завода в первом пункте и последующем перемещении завода с корректировкой общей стоимости. Для корректировки стоимости нужно поддерживать следующие показатели:<ul><li>количество мусора, до которого ближе ехать против часовой стрелки (s1);</li><li>количество мусора, до которого ближе ехать по часовой стрелке (s2).</li></ul></p><p>Стоимость транспортировки (p) корректируются количествами мусора (s1, s2). Сами количества мусора (s1, s2) меняются при перемещении завода.</p><p>Пример эффективного решения:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br /><span style="color:#0000ff;font-weight:400"># Вычисляем количество мусора по обе стороны от завода</span><br />s1 = <span style="color:#008a8c;font-weight:400">sum</span>(a[-(n // <span style="color:#ff00ff;font-weight:400">2</span>):])<br />s2 = <span style="color:#008a8c;font-weight:400">sum</span>(a[:n // <span style="color:#ff00ff;font-weight:400">2</span>])<br /><span style="color:#0000ff;font-weight:400"># Вычисляем стоимость транспортировки для завода в первом пункте</span><br />p = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />    p += <span style="color:#008a8c;font-weight:400">min</span>(i, n - i) * a[i]<br />m = p<br /><span style="color:#0000ff;font-weight:400"># Перебираем расположения завода, корректируем стоимость транспортировки</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, n):<br />    s1 += a[i - <span style="color:#ff00ff;font-weight:400">1</span>] - a[(i - <span style="color:#ff00ff;font-weight:400">1</span> - n // <span style="color:#ff00ff;font-weight:400">2</span>) % n]<br />    s2 -= a[i - <span style="color:#ff00ff;font-weight:400">1</span>] - a[(i - <span style="color:#ff00ff;font-weight:400">1</span> + n // <span style="color:#ff00ff;font-weight:400">2</span>) % n]<br />    p += s1 - s2<br />    m = <span style="color:#008a8c;font-weight:400">min</span>(m, p)<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p><h3>Эффективное решение (учёт особенностей)</h3></p><p>Дополнительные особенности, усложняющие решение:<ul><li>нахождение населённых пунктов не на каждом километре дороги; километровые отметки всех пунктов даны;</li><li>расчёт стоимости не по количеству единиц мусора, а по количеству рейсов мусоровоза.</li></ul></p><p>Проблему местоположения населённых пунктов проще всего решить, введя фиктивные населённые пункты, в которых 0 единиц мусора. Их наличие не повлияет на общую стоимость транспортировки, так как стоимость “транспортировки” 0 единиц мусора на любое расстояние равна 0.</p><p>Проблему учёта количества можно решить предварительным переводом единиц мусора в рейсы.</p><p>Пример эффективного решения:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n, k = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split())<br />    d = <span style="color:#ff00ff;font-weight:400">15</span> <span style="color:#0000ff;font-weight:400"># Вместимость мусоровоза</span><br />    a = [<span style="color:#ff00ff;font-weight:400">0</span>] * n<br />    <span style="color:#a52a2a;font-weight:700">for</span> _ <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(k):<br />        p, t = <span style="color:#008a8c;font-weight:400">map</span>(<span style="color:#008a8c;font-weight:400">int</span>, f.readline().split())<br />        a[p % n] = (t + d - <span style="color:#ff00ff;font-weight:400">1</span>) // d<br /><span style="color:#0000ff;font-weight:400"># Вычисляем количество мусора по обе стороны от завода</span><br />s1 = <span style="color:#008a8c;font-weight:400">sum</span>(a[-(n // <span style="color:#ff00ff;font-weight:400">2</span>):])<br />s2 = <span style="color:#008a8c;font-weight:400">sum</span>(a[:n // <span style="color:#ff00ff;font-weight:400">2</span>])<br /><span style="color:#0000ff;font-weight:400"># Вычисляем стоимость транспортировки для завода в первом пункте</span><br />p = <span style="color:#ff00ff;font-weight:400">0</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />    p += <span style="color:#008a8c;font-weight:400">min</span>(i, n - i) * a[i]<br />m = p<br /><span style="color:#0000ff;font-weight:400"># Перебираем расположения завода, корректируем стоимость транспортировки</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, n):<br />    s1 += a[i - <span style="color:#ff00ff;font-weight:400">1</span>] - a[(i - <span style="color:#ff00ff;font-weight:400">1</span> - n // <span style="color:#ff00ff;font-weight:400">2</span>) % n]<br />    s2 -= a[i - <span style="color:#ff00ff;font-weight:400">1</span>] - a[(i - <span style="color:#ff00ff;font-weight:400">1</span> + n // <span style="color:#ff00ff;font-weight:400">2</span>) % n]<br />    p += s1 - s2<br />    m = <span style="color:#008a8c;font-weight:400">min</span>(m, p)<br /><span style="color:#008a8c;font-weight:400">print</span>(m)</pre></div></p><p></p><p><h2>Перевозки: кольцевая дорога, разбиение на два фрагмента</h2></p><p>Типовой сюжет: на каждом километре кольцевого шоссе расположены пункты сбора мусора. Мусор собирают два одинаковых мусоровоза, въезжающие на шоссе в каких-либо точках, собирающих весь мусор (из каждого пункта мусор собирается ровно одним мусоровозом) и затем покидающих шоссе. Требуется определить минимально возможную вместимость мусоровозов и минимально возможное расстояние, которое проедет какой-либо из мусоровозов при выполнении условия на вместимость. </p><p>Исходные данные: количество пунктов N, затем N чисел: местоположение и количество мусора в каждом пункте по порядку расположения пунктов.</p><p></p><p><h3>Неэффективное решение</h3></p><p>Неэффективное решение основано на переборе вариантов распределения частей шоссе между мусоровозами, причём для каждого распределения заново полностью рассчитывается наполняемость мусоровозов и определяется пройденное каждым из них расстояние.</p><p>Пример неэффективного решения, использующего сравнение загрузок двух мусоровозов (более загруженный мусоровоз должен иметь как можно меньшую загрузку):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br /><span style="color:#0000ff;font-weight:400"># Получение общего количества мусора - для быстрого определения загрузки</span><br /><span style="color:#0000ff;font-weight:400"># второго мусоровоза по загрузке первого</span><br />t = <span style="color:#008a8c;font-weight:400">sum</span>(a)<br />m = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br />min_d = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />    s = <span style="color:#ff00ff;font-weight:400">0</span><br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />        s += a[(i + j) % n]<br />        d = <span style="color:#008a8c;font-weight:400">min</span>(j, n - <span style="color:#ff00ff;font-weight:400">2</span> - j)<br />        <span style="color:#a52a2a;font-weight:700">if</span> <span style="color:#008a8c;font-weight:400">max</span>(s, t - s) &lt; m:<br />            m = <span style="color:#008a8c;font-weight:400">max</span>(s, t - s)<br />            min_d = d<br />        <span style="color:#a52a2a;font-weight:700">elif</span> <span style="color:#008a8c;font-weight:400">max</span>(s, t - s) == m:<br />            min_d = <span style="color:#008a8c;font-weight:400">min</span>(min_d, d)<br /><span style="color:#008a8c;font-weight:400">print</span>(min_d)</pre></div></p><p>При минимальной загрузке большего мусоровоза определяется минимальное расстояние, которое проедет один из мусоровозов. При въезде на шоссе и съезде с него мусоровозы могут сэкономить по 1 километру пути, т. к. они могут въехать в соседние пункты, а съехать в других соседних. Общее расстояние, пройденное суммарно обоими мусоровозами, составляет N-2 км.</p><p></p><p><h3>Эффективное решение</h3></p><p>Эффективное решение использует следующие идеи:<ul><li>задвоить список пунктов, чтобы как бы развернуть в кольцевую линию в прямую;</li><li>максимизировать загрузку мусоровоза с меньшей загрузкой: загрузка должна быть как можно больше, но не превышать половину от общего количества мусора;</li><li>при поиске непрерывных подпоследовательности с заданной максимальной суммой используется разновидность метода двух указателей, метод скользящего окна. </li></ul></p><p>Пример эффективного решения:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br /><span style="color:#0000ff;font-weight:400"># Полусумма - целевая сумма для мусоровоза с меньшей заполняемостью</span><br />ps = <span style="color:#008a8c;font-weight:400">sum</span>(a) // <span style="color:#ff00ff;font-weight:400">2</span><br /><span style="color:#0000ff;font-weight:400"># Повторение пунктов сбора, чтобы не заворачиваться на начало массива</span><br />a = a * <span style="color:#ff00ff;font-weight:400">2</span><br /><span style="color:#0000ff;font-weight:400"># Инициализация индексов и показателей</span><br />left, right = <span style="color:#ff00ff;font-weight:400">0</span>, <span style="color:#ff00ff;font-weight:400">0</span><br />s = a[<span style="color:#ff00ff;font-weight:400">0</span>]<br />max_s = <span style="color:#ff00ff;font-weight:400">0</span><br />min_d = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br /><span style="color:#0000ff;font-weight:400"># Проход двух указателей</span><br /><span style="color:#a52a2a;font-weight:700">while</span> right &lt; <span style="color:#008a8c;font-weight:400">len</span>(a) - <span style="color:#ff00ff;font-weight:400">1</span>:<br />    <span style="color:#a52a2a;font-weight:700">if</span> s &lt;= ps:<br />        <span style="color:#0000ff;font-weight:400"># Сумма мала, двигаем правую границу</span><br />        right += <span style="color:#ff00ff;font-weight:400">1</span><br />        s += a[right]<br />    <span style="color:#a52a2a;font-weight:700">else</span>:<br />        <span style="color:#0000ff;font-weight:400"># Сумма велика, двигаем левую границу</span><br />        s -= a[left]<br />        left += <span style="color:#ff00ff;font-weight:400">1</span><br />    <span style="color:#a52a2a;font-weight:700">if</span> s &lt;= ps:<br />        <span style="color:#0000ff;font-weight:400"># Сумма в пределах половины от общей, пробуем обновить показатели</span><br />        d = right - left<br />        d = <span style="color:#008a8c;font-weight:400">min</span>(d, n - <span style="color:#ff00ff;font-weight:400">2</span> - d)<br />        <span style="color:#a52a2a;font-weight:700">if</span> s &gt; max_s:<br />            max_s = s<br />            min_d = d<br />        <span style="color:#a52a2a;font-weight:700">elif</span> s == max_s:<br />            min_d = <span style="color:#008a8c;font-weight:400">min</span>(min_d, d)<br /><span style="color:#008a8c;font-weight:400">print</span>(min_d)</pre></div></p><p></p><p><h2>Подпоследовательность с заданной суммой, самая короткая</h2></p><p>Дана последовательность чисел. Требуется найти её самую короткую непрерывную подпоследовательность с суммой, равной (или не меньшей) заданной.</p><p><h3>Неэффективное решение</h3></p><p>Неэффективное решение состоит в переборе всех подпоследовательностей (индексов их начальных элементов и конечных элементов), вычислении сумм элементов в них, проверке этих сумм и длин подпоследовательностей.</p><p>Пример такого неэффективного решения:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />p = <span style="color:#ff00ff;font-weight:400">100</span> <span style="color:#0000ff;font-weight:400"># Целевая сумма</span><br />d = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i, n):<br />        s = <span style="color:#ff00ff;font-weight:400">0</span><br />        <span style="color:#a52a2a;font-weight:700">for</span> k <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i, j + <span style="color:#ff00ff;font-weight:400">1</span>):<br />            s += a[k]<br />        <span style="color:#a52a2a;font-weight:700">if</span> s == p:<br />            d = <span style="color:#008a8c;font-weight:400">min</span>(d, j - i + <span style="color:#ff00ff;font-weight:400">1</span>)<br /><span style="color:#008a8c;font-weight:400">print</span>(d)</pre></div></p><p>Решение можно сделать более эффективным, избавив его от третьего вложенного цикла. Можно заметить, что при фиксированном начале подпоследовательности можно добавлять к ней следующие элементы последовательности, рассматривая каждый результат сложения как сумму элементов очередной подпоследовательности и сравнивая его с заданным числом. Это позволит не пересчитывать сумму элементов каждой подпоследовательности заново. Однако для последовательностей, которые начинаются в другом месте, сумму всё ещё придётся пересчитывать заново. </p><p>Пример такого решения (всё ещё недостаточно эффективного):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />p = <span style="color:#ff00ff;font-weight:400">100</span> <span style="color:#0000ff;font-weight:400"># Целевая сумма</span><br />d = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i, n):<br />        s = <span style="color:#ff00ff;font-weight:400">0</span><br />        <span style="color:#a52a2a;font-weight:700">for</span> k <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i, j + <span style="color:#ff00ff;font-weight:400">1</span>):<br />            s += a[k]<br />        <span style="color:#a52a2a;font-weight:700">if</span> s == p:<br />            d = <span style="color:#008a8c;font-weight:400">min</span>(d, j - i + <span style="color:#ff00ff;font-weight:400">1</span>)<br /><span style="color:#008a8c;font-weight:400">print</span>(d)</pre></div></p><p></p><p><h3>Эффективное решение</h3></p><p>Можно заметить, что при расширении подпоследовательности вправо сумма её элементов строго увеличивается, а при её сокращении слева сумма её элементов строго уменьшается. Таким образом, можно двигать правую границу подпоследовательности вправо (расширяем подпоследовательность), пока её сумма не будет больше заданного числа равна, в противном случае двигаем левую границу вправо (сокращаем подпоследовательность), пока её сумма не будет опять меньше заданного числа, и в процессе этих движений анализируем полученные суммы. Этот метод решения - частный случай метода двух указателей, поскольку поиск результата осуществляется движением двух индексов. Также способ решения задачи содержит элементы метода скользящего окна: подпоследовательность - это как бы окно переменного размера, которое мы двигаем слева направо по последовательности и через которое видно подпоследовательности.</p><p>Пример эффективного решения:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />p = <span style="color:#ff00ff;font-weight:400">100</span> <span style="color:#0000ff;font-weight:400"># Целевая сумма</span><br />d = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br />left = right = <span style="color:#ff00ff;font-weight:400">0</span><br />s = a[<span style="color:#ff00ff;font-weight:400">0</span>]<br /><span style="color:#a52a2a;font-weight:700">if</span> s == p:<br />    <span style="color:#008a8c;font-weight:400">print</span>(<span style="color:#ff00ff;font-weight:400">1</span>)<br />    exit()<br /><span style="color:#a52a2a;font-weight:700">while</span> right &lt; n - <span style="color:#ff00ff;font-weight:400">1</span>:<br />    <span style="color:#a52a2a;font-weight:700">if</span> s &lt; p:<br />        right += <span style="color:#ff00ff;font-weight:400">1</span><br />        s += a[right]<br />    <span style="color:#a52a2a;font-weight:700">else</span>:<br />        s -= a[left]<br />        left += <span style="color:#ff00ff;font-weight:400">1</span><br />    <span style="color:#a52a2a;font-weight:700">if</span> s == p:<br />        d = <span style="color:#008a8c;font-weight:400">min</span>(d, right - left + <span style="color:#ff00ff;font-weight:400">1</span>)<br /><span style="color:#008a8c;font-weight:400">print</span>(d)</pre></div></p><p></p><p><h2>Подпоследовательность с максимальной суммой, делящейся на N, самая короткая</h2></p><p></p><p><h3>Неэффективное решение</h3></p><p>Неэффективное решение заключается в переборе всех подпоследовательностей, вычислении суммы элементов каждой из них, проверке суммы на делимость и поддержании двух показателей:<ul><li>максимальная сумма, делящаяся на заданное число;</li><li>минимальная длина подпоследовательности, имеющей эту сумму (значение для ответа).</li></ul></p><p>Пример неэффективного решения:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />d = <span style="color:#ff00ff;font-weight:400">43</span> <span style="color:#0000ff;font-weight:400"># Число, на которое должна делиться сумма элементов подпоследовательности</span><br />ms = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br />md = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br /><span style="color:#0000ff;font-weight:400"># Перебор подпоследовательностей</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i, n):<br />        s = <span style="color:#ff00ff;font-weight:400">0</span><br />        <span style="color:#a52a2a;font-weight:700">for</span> k <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i, j + <span style="color:#ff00ff;font-weight:400">1</span>):<br />            s += a[k]<br />        <span style="color:#a52a2a;font-weight:700">if</span> s % d == <span style="color:#ff00ff;font-weight:400">0</span>:<br />            <span style="color:#a52a2a;font-weight:700">if</span> s &gt; ms:<br />                ms = s<br />                md = j - i + <span style="color:#ff00ff;font-weight:400">1</span><br />            <span style="color:#a52a2a;font-weight:700">elif</span> s == ms:<br />                md = <span style="color:#008a8c;font-weight:400">min</span>(md, j - i + <span style="color:#ff00ff;font-weight:400">1</span>)<br /><span style="color:#008a8c;font-weight:400">print</span>(md, ms)</pre></div></p><p>Более эффективное решение основано на использовании префиксных сумм.</p><p>Префиксные суммы позволяют за один проход по последовательности получать данные, необходимые для мгновенного вычисления суммы элементов любой её подпоследовательности.</p><p>Возьмём следующую последовательность чисел:</p><p><table class="table"><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr><tr><td>a[i]</td><td>4</td><td>9</td><td>2</td><td>3</td><td>5</td><td>7</td><td>8</td><td>1</td><td>6</td></tr></table></p><p>Создадим массив, имеющий на 1 элемент больше. Первый его элемент сделаем равным 0, а каждый следующий будет равен сумме его предыдущего элемента и очередного элемента исходной последовательности:</p><p><table class="table"><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr><tr><td>p[i]</td><td>0</td><td>4</td><td>13</td><td>15</td><td>18</td><td>23</td><td>30</td><td>38</td><td>39</td><td>45</td></tr></table></p><p>Тогда элементов последовательности a[i], a[i + 1],..., a[j] может быть получена как разность префиксных сумм: p[j + 1]-p[i].</p><p>Например, сумма элементов последовательности с a[2] по a[6] включительно (2+3+5+7+8=25) может быть мгновенно получена как разность p[7]-p[2]=25.</p><p>Более эффективное решение (всё ещё недостаточно эффективное):</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    a = [<span style="color:#008a8c;font-weight:400">int</span>(x) <span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> f]<br />d = <span style="color:#ff00ff;font-weight:400">43</span> <span style="color:#0000ff;font-weight:400"># Число, на которое должна делиться сумма элементов подпоследовательности</span><br /><span style="color:#0000ff;font-weight:400"># Создание массива префиксных сумм</span><br />p = [<span style="color:#ff00ff;font-weight:400">0</span>]<br /><span style="color:#a52a2a;font-weight:700">for</span> x <span style="color:#a52a2a;font-weight:700">in</span> a:<br />    p.append(p[-<span style="color:#ff00ff;font-weight:400">1</span>] + x)<br />ms = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;-inf&#39;</span>)<br />md = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br /><span style="color:#0000ff;font-weight:400"># Перебор подпоследовательностей</span><br /><span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(n):<br />    <span style="color:#a52a2a;font-weight:700">for</span> j <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(i, n):<br />        s = p[j + <span style="color:#ff00ff;font-weight:400">1</span>] - p[i]<br />        <span style="color:#a52a2a;font-weight:700">if</span> s % d == <span style="color:#ff00ff;font-weight:400">0</span>:<br />            <span style="color:#a52a2a;font-weight:700">if</span> s &gt; ms:<br />                ms = s<br />                md = j - i + <span style="color:#ff00ff;font-weight:400">1</span><br />            <span style="color:#a52a2a;font-weight:700">elif</span> s == ms:<br />                md = <span style="color:#008a8c;font-weight:400">min</span>(md, j - i + <span style="color:#ff00ff;font-weight:400">1</span>)<br /><span style="color:#008a8c;font-weight:400">print</span>(md, ms)</pre></div></p><p></p><p><h3>Эффективное решение</h3></p><p>Эффективное решение основано на использовании префиксных сумм в качестве элементов самостоятельной последовательности. Для каждого элемента исходной последовательности можно получить соответствующий элемент последовательности префиксных сумм, означающий сумму всех элементов исходной последовательности до текущего включительно. Сумма элементов произвольной подпоследовательности (не обязательно с начала последовательности) может быть найдена как разность префиксных сумм.</p><p>Для того, чтобы сумма элементов исходной подпоследовательности (она же - разность двух префиксных сумм) делилась на какое-либо число, необходимо и достаточно, чтобы  обе префиксные суммы имели одинаковые остатки от деления на это число.</p><p>Таким образом, исходная задача может быть сведена к следующим пунктам:<ol><li>преобразовывать элементы исходной последовательности в их префиксные суммы;</li><li>для последовательности префиксных сумм определять пару с максимальной разностью чисел, делящейся на заданное число;</li><li>при максимальном значении разности определять пару с минимальной разностью индексов.</li></ol></p><p>Преобразование исходных элементов последовательности в префиксные суммы можно выполнить с помощью одной переменной, в которой накапливается сумма элементов исходной последовательности. Получаемые префиксные суммы можно не хранить в отдельном массиве, т. к. они сразу будут учтены в статистике.</p><p>Определение пары элементов с максимальной разностью чисел, делящейся на заданное число, можно осуществить с помощью статистики по остаткам. Это было рассмотрено при решении соответствующей задачи. В статистике для данной задачи нужно отражать минимальные числа (префиксные суммы), имеющие тот или иной остаток. Поскольку элементы последовательности префиксных сумм строго возрастают, второе число в паре всегда будет больше первого, и в качестве минимального числа всегда будет выступать первое число с данным остатком, и элемент статистики больше не будет обновляться. В приведённом решении список с этой статистикой - prev_sums.</p><p>Для определения минимальной разности индексов нужна отдельная статистика по последним индексам минимальных элементов, имеющих тот или иной остаток. В приведённом решении список с этой статистикой - prev_ind.</p><p>Пример эффективного решения:</p><p><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">with</span> <span style="color:#008a8c;font-weight:400">open</span>(<span style="color:#ff00ff;font-weight:400">&#39;input.txt&#39;</span>) <span style="color:#a020f0;font-weight:400">as</span> f:<br />    n = <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />    d = <span style="color:#ff00ff;font-weight:400">43</span> <span style="color:#0000ff;font-weight:400"># Число, на которое должна делиться сумма элементов подпоследовательности</span><br />    prev_sums = [<span style="color:#ff00ff;font-weight:400">None</span>] * d<br />    prev_ind = [<span style="color:#ff00ff;font-weight:400">0</span>] * d<br />    prev_sums[<span style="color:#ff00ff;font-weight:400">0</span>] = <span style="color:#ff00ff;font-weight:400">0</span><br />    s = <span style="color:#ff00ff;font-weight:400">0</span><br />    max_s = <span style="color:#ff00ff;font-weight:400">0</span><br />    k = <span style="color:#008a8c;font-weight:400">float</span>(<span style="color:#ff00ff;font-weight:400">&#39;inf&#39;</span>)<br />    <span style="color:#a52a2a;font-weight:700">for</span> i <span style="color:#a52a2a;font-weight:700">in</span> <span style="color:#008a8c;font-weight:400">range</span>(<span style="color:#ff00ff;font-weight:400">1</span>, n + <span style="color:#ff00ff;font-weight:400">1</span>):<br />        <span style="color:#0000ff;font-weight:400"># Вычисление накопленной суммы</span><br />        s += <span style="color:#008a8c;font-weight:400">int</span>(f.readline())<br />        <span style="color:#a52a2a;font-weight:700">if</span> prev_sums[s % d] <span style="color:#a52a2a;font-weight:700">is</span> <span style="color:#ff00ff;font-weight:400">None</span>:<br />            <span style="color:#0000ff;font-weight:400"># Суммы с таким остатком ещё не было, запоминаем её и индекс последнего элемента</span><br />            prev_sums[s % d] = s<br />            prev_ind[s % d] = i<br />        <span style="color:#a52a2a;font-weight:700">else</span>:<br />            <span style="color:#0000ff;font-weight:400"># Сумма с таким остатком уже была, обновляем показатели</span><br />            diff_s = s - prev_sums[s % d]<br />            <span style="color:#a52a2a;font-weight:700">if</span> diff_s &gt; max_s:<br />                max_s = diff_s<br />                k = i - prev_ind[s % d]<br />            <span style="color:#a52a2a;font-weight:700">elif</span> diff_s == max_s:<br />                k = <span style="color:#008a8c;font-weight:400">min</span>(k, i - prev_ind[s % d])<br />    <span style="color:#008a8c;font-weight:400">print</span>(k, max_s)</pre></div></p></div><div class='page'><a name="СИСТЕМЫ_СЧИСЛЕНИЯ_30.html"></a><h1 class='title level-1'>СИСТЕМЫ СЧИСЛЕНИЯ</h1><br/><p><h1>Перевод в десятичную систему счисления</h1></p><p>Получение десятичной записи натурального числа по его записи в заданной позиционной системе счисления.</p><p></p><p><h2>Алгоритм с разложением на степени</h2><ol><li>Нумеруем разряды справа налево с 0.</li><li>Записываем сумму разрядных слагаемых.</li><li>Вычисляем сумму.</li></ol></p><p></p><p><h2>Алгоритм с использованием схемы Горнера</h2></p><p>Меньше действий, чем при разложении на степени, больше промежуточные числа. Алгоритм лучше подходит для калькуляторов.<ol><li>Берём старшую цифру.</li><li>Умножаем на основание системы счисления.</li><li>Прибавляем следующую цифру.</li><li>Повторяем пп. 2-3, пока цифры не закончатся.</li></ol></p><p></p><p>Для систем счисления с основанием больше 10 учитываем, что A = 10 и т. д.</p><p></p><p><h1>Перевод в любую позиционную систему счисления</h1></p><p>Получение записи натурального числа в заданной системе счисления по его десятичной записи.<ol><li>Делим число на основание нужной системы счисления.</li><li>Частное опять делим и т. д., пока не равно 0.</li><li>Остатки выписываем в обратном порядке.</li></ol></p><p></p><p>Для систем счисления с основанием больше 10 учитываем, что A = 10 и т. д.</p><p></p></div><div class='page'><a name="PYTHON_33.html"></a><h1 class='title level-1'>PYTHON</h1><br/><p><h1>Среды</h1><ul><li>IDLE</li><li>PyCharm</li><li>Wing IDE</li><li>Geany</li><li>Visual Studio Code</li><li>Онлайн-среды:<ul><li><a href="https://onlinegdb.com">onlinegdb.com</a></li></ul></li></ul></p><p></p><p><h1>Ввод и вывод</h1><ul><li>print<ul><li>sep</li><li>end</li></ul></li><li>input</li></ul></p><p></p><p><h1>Типы данных</h1><ul><li>базовые:<ul><li>int</li><li>float</li><li>bool</li><li>str</li><li>NoneType (None)</li></ul></li><li>преобразования:<ul><li>int(строка, основание)</li><li>bin (0b...)</li><li>oct (0o...)</li><li>hex (0x...)</li></ul></li></ul></p><p></p><p><h1>Переменные</h1><ul><li>присваивание:<ul><li>обычное: x = 7</li><li>совмещённое: x += 1</li><li>каскадное: x = y = 5</li><li>множественное: x, y = 7, 5</li></ul></li><li>удаление: del</li></ul></p><p></p><p><h1>Арифметика</h1><ul><li>операции: +, -, *, /, //, %, **</li><li>особенности целочисленного деления отрицательных чисел </li><li>поддержка длинной арифметики</li><li>вещественные значения “бесконечность”</li></ul></p><p></p><p><h1>Условия и ветвления</h1><ul><li>if, else, elif</li><li>логические операции: &gt;, &lt;, ==, &lt;=, &gt;=, !=</li><li>not, and, or</li><li>in</li><li>множественные неравенства: a &lt; b &lt; c</li><li>замена импликации: &lt;=</li><li>замена исключающего “или”: !=, ^</li><li>any, all</li></ul></p><p></p><p><h1>Циклы</h1><ul><li>while</li><li>for<ul><li>range</li><li>enumerate</li><li>итераторы в целом</li></ul></li><li>break, continue, else</li></ul></p><p></p><p><h1>Списки</h1><ul><li>задание списка: list(), [], [1, 5, 4]</li><li>индексы - с 0, отрицательные - с конца</li><li>итерирование (for ... in)</li><li>проверка вхождения (in)</li><li>добавление (append)</li><li>вставка (insert)</li><li>удаление (pop, remove)</li><li>длина списка (len)</li><li>подсчёт числа некоторых элементов (count)</li><li>конкатенация (+), повторение (*)</li><li>включения<ul><li>[i*i for i in range(1, 21)]</li><li>[i*i for i in range(1, 21) if i % 2 == 0]</li></ul></li><li>срезы<ul><li>a[старт:стоп]</li><li>a[старт:стоп:шаг]</li></ul></li><li>сортировка (sort), указание направления, указание ключа сортировки</li></ul></p><p></p><p><h1>Кортежи</h1><ul><li>задание списка: tuple(), (1, 5, 4)</li><li>неизменяемость, остальное - как у списков.</li></ul></p><p></p><p><h1>Строки</h1><ul><li>задание строки: str, &#39;&#39;, &quot;&quot;</li><li>многострочные строки: &#39;&#39;&#39;...&#39;&#39;&#39;, &quot;&quot;&quot;...&quot;&quot;&quot;</li><li>индексы - с 0, отрицательные - с конца</li><li>итерирование (for ... in)</li><li>проверка вхождения (in)</li><li>длина строки (len)</li><li>замена (replace)</li><li>разделение (split)</li><li>соединение (join)</li><li>убирание невидимых символов (strip)</li><li>дополнение нулями (zfill)</li><li>конкатенация (+), повторение (*)</li><li>срезы<ul><li>a[старт:стоп]</li><li>a[старт:стоп:шаг]</li></ul></li><li>сравнение строк</li><li>форматные строки<ul><li>&#39;строка&#39; % формат</li><li>f-строки</li></ul></li><li>спецсимволы, экранирование</li></ul></p><p></p><p><h1>Множества</h1><ul><li>задание множества: set(), {1, 5, 4}</li><li>итерирование (for ... in)</li><li>проверка вхождения (in)</li><li>добавление (add)</li><li>удаление (remove)</li><li>мощность множества (len)</li></ul></p><p></p><p><h1>Словари</h1><ul><li>задание словаря: dict(), {}, {&#39;a&#39;: 1, &#39;b&#39;: 2}</li></ul></p><p></p><p><h1>Функции</h1><ul><li>def</li><li>аругменты</li><li>return</li></ul></p><p></p><p><h1>Прочее</h1><ul><li>выражения-генераторы: (i*i for i in range(1, 21))</li><li>анонимные функции: lambda</li><li>map</li><li>zip</li></ul></p><p></p><p><h1>Файлы</h1><ul><li>open</li><li>close</li><li>readline</li><li>readlines</li><li>файловая переменная как итератор</li></ul></p><p></p><p><h1>Контекст</h1><ul><li>with</li></ul></p><p></p><p><h1>Модули</h1><ul><li>import, from, as</li><li>fnmatch: fnmatch</li><li>re: compile, search, match</li><li>turtle</li><li>itertools: product, permutations, combinations</li><li>functools: lru_cache, cache</li><li>ipaddress: ip_network</li><li>collections: Counter</p><p></li></ul></p></div><div class='page'><a name="ТАБЛИЧНЫЙ_ПРОЦЕССОР_34.html"></a><h1 class='title level-1'>ТАБЛИЧНЫЙ ПРОЦЕССОР</h1><br/><p><h1>Основные понятия</h1><ul><li>лист</li><li>строка</li><li>столбец</li><li>ячейка</li><li>диапазон</li></ul></p><p></p><p><h1>Значения и форматы</h1><ul><li>текст</li><li>число</li><li>дата</li><li>булево (логическое) значение</li><li>формула</li><li>настройка формата ячеек</li></ul></p><p></p><p><h1>Основные операции</h1><ul><li>выделение</li><li>копирование, вырезание, вставка</li><li>протягивание</li><li>использование видов адресации в формулах</li><li>специальная вставка</li></ul></p><p></p><p><h1>Функции</h1><ul><li>Основные: СУММ, СРЗНАЧ, МАКС, МИН, СЧЁТ, СУММКВ</li><li>Условные: СУММЕСЛИ, СЧЁТЕСЛИ, ЕСЛИ</li><li>Логические: НЕ, И, ИЛИ</li><li>Статистические: НАИБОЛЬШИЙ, НАИМЕНЬШИЙ, МЕДИАНА, МОДА</li><li>Прочие: ОСТАТ, ВПР</li></ul></p><p></p><p><h1>Возможности работы с данными</h1><ul><li>открытие текстовых файлов</li><li>сортировка и фильтры</li><li>сводные таблицы</li></ul></p></div>
</body>
</html>
